var define, requireModule;

(function() {
  var registry = {}, seen = {};

  define = function(name, deps, callback) {
    registry[name] = { deps: deps, callback: callback };
  };

  requireModule = function(name) {
    if (seen[name]) { return seen[name]; }
    seen[name] = {};

    var mod = registry[name],
        deps = mod.deps,
        callback = mod.callback,
        reified = [],
        exports;

    for (var i=0, l=deps.length; i<l; i++) {
      if (deps[i] === 'exports') {
        reified.push(exports = {});
      } else {
        reified.push(requireModule(deps[i]));
      }
    }

    var value = callback.apply(this, reified);
    return seen[name] = exports || value;
  };
})();
minispade.register('ember-data/adapters', "(function() {/**\n  Adapters included with Ember-Data.\n\n  @module data\n  @submodule data-adapters\n\n  @main data-adapters\n*/\nminispade.require(\"ember-data/adapters/fixture_adapter\");\nminispade.require(\"ember-data/adapters/rest_adapter\");\n\n})();\n//@ sourceURL=ember-data/adapters");minispade.register('ember-data/adapters/fixture_adapter', "(function() {minispade.require(\"ember-data/core\");\nminispade.require(\"ember-data/system/adapter\");\nminispade.require('ember-data/serializers/fixture_serializer');\n\n/**\n  @module data\n  @submodule data-adapters\n*/\n\nvar get = Ember.get, fmt = Ember.String.fmt,\n    dump = Ember.get(window, 'JSON.stringify') || function(object) { return object.toString(); };\n\n/**\n  `DS.FixtureAdapter` is an adapter that loads records from memory.\n  Its primarily used for development and testing. You can also use\n  `DS.FixtureAdapter` while working on the API but are not ready to\n  integrate yet. It is a fully functioning adapter. All CRUD methods\n  are implemented. You can also implement query logic that a remote\n  system would do. Its possible to do develop your entire application\n  with `DS.FixtureAdapter`.\n\n  @class FixtureAdapter\n  @constructor\n  @namespace DS\n  @extends DS.Adapter\n*/\nDS.FixtureAdapter = DS.Adapter.extend({\n\n  simulateRemoteResponse: true,\n\n  latency: 50,\n\n  serializer: DS.FixtureSerializer,\n\n  /*\n    Implement this method in order to provide data associated with a type\n  */\n  fixturesForType: function(type) {\n    if (type.FIXTURES) {\n      var fixtures = Ember.A(type.FIXTURES);\n      return fixtures.map(function(fixture){\n        var fixtureIdType = typeof fixture.id;\n        if(fixtureIdType !== \"number\" && fixtureIdType !== \"string\"){\n          throw new Error(fmt('the id property must be defined as a number or string for fixture %@', [dump(fixture)]));\n        }\n        fixture.id = fixture.id + '';\n        return fixture;\n      });\n    }\n    return null;\n  },\n\n  /*\n    Implement this method in order to query fixtures data\n  */\n  queryFixtures: function(fixtures, query, type) {\n    Ember.assert('Not implemented: You must override the DS.FixtureAdapter::queryFixtures method to support querying the fixture store.');\n  },\n\n  updateFixtures: function(type, fixture) {\n    if(!type.FIXTURES) {\n      type.FIXTURES = [];\n    }\n\n    var fixtures = type.FIXTURES;\n\n    this.deleteLoadedFixture(type, fixture);\n\n    fixtures.push(fixture);\n  },\n\n  /*\n    Implement this method in order to provide provide json for CRUD methods\n  */\n  mockJSON: function(type, record) {\n    return this.serialize(record, { includeId: true });\n  },\n\n  /*\n    Adapter methods\n  */\n  generateIdForRecord: function(store, record) {\n    return Ember.guidFor(record);\n  },\n\n  find: function(store, type, id) {\n    var fixtures = this.fixturesForType(type),\n        fixture;\n\n    Ember.warn(\"Unable to find fixtures for model type \" + type.toString(), fixtures);\n\n    if (fixtures) {\n      fixture = Ember.A(fixtures).findProperty('id', id);\n    }\n\n    if (fixture) {\n      this.simulateRemoteCall(function() {\n        this.didFindRecord(store, type, fixture, id);\n      }, this);\n    }\n  },\n\n  findMany: function(store, type, ids) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), !!fixtures);\n\n    if (fixtures) {\n      fixtures = fixtures.filter(function(item) {\n        return ids.indexOf(item.id) !== -1;\n      });\n    }\n\n    if (fixtures) {\n      this.simulateRemoteCall(function() {\n        this.didFindMany(store, type, fixtures);\n      }, this);\n    }\n  },\n\n  findAll: function(store, type) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), !!fixtures);\n\n    this.simulateRemoteCall(function() {\n      this.didFindAll(store, type, fixtures);\n    }, this);\n  },\n\n  findQuery: function(store, type, query, array) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), !!fixtures);\n\n    fixtures = this.queryFixtures(fixtures, query, type);\n\n    if (fixtures) {\n      this.simulateRemoteCall(function() {\n        this.didFindQuery(store, type, fixtures, array);\n      }, this);\n    }\n  },\n\n  createRecord: function(store, type, record) {\n    var fixture = this.mockJSON(type, record);\n\n    this.updateFixtures(type, fixture);\n\n    this.simulateRemoteCall(function() {\n      this.didCreateRecord(store, type, record, fixture);\n    }, this);\n  },\n\n  updateRecord: function(store, type, record) {\n    var fixture = this.mockJSON(type, record);\n\n    this.updateFixtures(type, fixture);\n\n    this.simulateRemoteCall(function() {\n      this.didUpdateRecord(store, type, record, fixture);\n    }, this);\n  },\n\n  deleteRecord: function(store, type, record) {\n    var fixture = this.mockJSON(type, record);\n\n    this.deleteLoadedFixture(type, fixture);\n\n    this.simulateRemoteCall(function() {\n      this.didDeleteRecord(store, type, record);\n    }, this);\n  },\n\n  /*\n    @private\n  */\n deleteLoadedFixture: function(type, record) {\n    var existingFixture = this.findExistingFixture(type, record);\n\n    if(existingFixture) {\n      var index = type.FIXTURES.indexOf(existingFixture);\n      type.FIXTURES.splice(index, 1);\n      return true;\n    }\n  },\n\n  findExistingFixture: function(type, record) {\n    var fixtures = this.fixturesForType(type);\n    var id = this.extractId(type, record);\n\n    return this.findFixtureById(fixtures, id);\n  },\n\n  findFixtureById: function(fixtures, id) {\n    return Ember.A(fixtures).find(function(r) {\n      if(''+get(r, 'id') === ''+id) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n  },\n\n  simulateRemoteCall: function(callback, context) {\n    if (get(this, 'simulateRemoteResponse')) {\n      // Schedule with setTimeout\n      Ember.run.later(context, callback, get(this, 'latency'));\n    } else {\n      // Asynchronous, but at the of the runloop with zero latency\n      Ember.run.once(context, callback);\n    }\n  }\n});\n\n})();\n//@ sourceURL=ember-data/adapters/fixture_adapter");minispade.register('ember-data/adapters/rest_adapter', "(function() {minispade.require(\"ember-data/core\");\nminispade.require('ember-data/system/adapter');\nminispade.require('ember-data/serializers/rest_serializer');\n/*global jQuery*/\n\n/**\n  @module data\n  @submodule data-adapters\n*/\n\nvar get = Ember.get, set = Ember.set;\n\nfunction rejectionHandler(reason) {\n  Ember.Logger.error(reason, reason.message);\n  throw reason;\n}\n\n/**\n  The REST adapter allows your store to communicate with an HTTP server by\n  transmitting JSON via XHR. Most Ember.js apps that consume a JSON API\n  should use the REST adapter.\n\n  This adapter is designed around the idea that the JSON exchanged with\n  the server should be conventional.\n\n  ## JSON Structure\n\n  The REST adapter expects the JSON returned from your server to follow\n  these conventions.\n\n  ### Object Root\n\n  The JSON payload should be an object that contains the record inside a\n  root property. For example, in response to a `GET` request for\n  `/posts/1`, the JSON should look like this:\n\n  ```js\n  {\n    \"post\": {\n      title: \"I'm Running to Reform the W3C's Tag\",\n      author: \"Yehuda Katz\"\n    }\n  }\n  ```\n\n  ### Conventional Names\n\n  Attribute names in your JSON payload should be the underscored versions of\n  the attributes in your Ember.js models.\n\n  For example, if you have a `Person` model:\n\n  ```js\n  App.Person = DS.Model.extend({\n    firstName: DS.attr('string'),\n    lastName: DS.attr('string'),\n    occupation: DS.attr('string')\n  });\n  ```\n\n  The JSON returned should look like this:\n\n  ```js\n  {\n    \"person\": {\n      \"first_name\": \"Barack\",\n      \"last_name\": \"Obama\",\n      \"occupation\": \"President\"\n    }\n  }\n  ```\n\n  @class RESTAdapter\n  @constructor\n  @namespace DS\n  @extends DS.Adapter\n*/\nDS.RESTAdapter = DS.Adapter.extend({\n  namespace: null,\n  bulkCommit: false,\n  since: 'since',\n\n  serializer: DS.RESTSerializer,\n\n  init: function() {\n    this._super.apply(this, arguments);\n  },\n\n  shouldSave: function(record) {\n    var reference = get(record, '_reference');\n\n    return !reference.parent;\n  },\n\n  dirtyRecordsForRecordChange: function(dirtySet, record) {\n    this._dirtyTree(dirtySet, record);\n  },\n\n  dirtyRecordsForHasManyChange: function(dirtySet, record, relationship) {\n    var embeddedType = get(this, 'serializer').embeddedType(record.constructor, relationship.secondRecordName);\n\n    if (embeddedType === 'always') {\n      relationship.childReference.parent = relationship.parentReference;\n      this._dirtyTree(dirtySet, record);\n    }\n  },\n\n  _dirtyTree: function(dirtySet, record) {\n    dirtySet.add(record);\n\n    get(this, 'serializer').eachEmbeddedRecord(record, function(embeddedRecord, embeddedType) {\n      if (embeddedType !== 'always') { return; }\n      if (dirtySet.has(embeddedRecord)) { return; }\n      this._dirtyTree(dirtySet, embeddedRecord);\n    }, this);\n\n    var reference = record.get('_reference');\n\n    if (reference.parent) {\n      var store = get(record, 'store');\n      var parent = store.recordForReference(reference.parent);\n      this._dirtyTree(dirtySet, parent);\n    }\n  },\n\n  createRecord: function(store, type, record) {\n    var root = this.rootForType(type);\n    var adapter = this;\n    var data = {};\n\n    data[root] = this.serialize(record, { includeId: true });\n\n    return this.ajax(this.buildURL(root), \"POST\", {\n      data: data\n    }).then(function(json){\n      adapter.didCreateRecord(store, type, record, json);\n    }, function(xhr) {\n      adapter.didError(store, type, record, xhr);\n      throw xhr;\n    }).then(null, rejectionHandler);\n  },\n\n  createRecords: function(store, type, records) {\n    var adapter = this;\n\n    if (get(this, 'bulkCommit') === false) {\n      return this._super(store, type, records);\n    }\n\n    var root = this.rootForType(type),\n        plural = this.pluralize(root);\n\n    var data = {};\n    data[plural] = [];\n    records.forEach(function(record) {\n      data[plural].push(this.serialize(record, { includeId: true }));\n    }, this);\n\n    return this.ajax(this.buildURL(root), \"POST\", {\n      data: data\n    }).then(function(json) {\n      adapter.didCreateRecords(store, type, records, json);\n    }).then(null, rejectionHandler);\n  },\n\n  updateRecord: function(store, type, record) {\n    var id, root, adapter, data;\n\n    id = get(record, 'id');\n    root = this.rootForType(type);\n    adapter = this;\n\n    data = {};\n    data[root] = this.serialize(record);\n\n    return this.ajax(this.buildURL(root, id), \"PUT\",{\n      data: data\n    }).then(function(json){\n      adapter.didUpdateRecord(store, type, record, json);\n    }, function(xhr) {\n      adapter.didError(store, type, record, xhr);\n      throw xhr;\n    }).then(null, rejectionHandler);\n  },\n\n  updateRecords: function(store, type, records) {\n    var root, plural, adapter, data;\n\n    if (get(this, 'bulkCommit') === false) {\n      return this._super(store, type, records);\n    }\n\n    root = this.rootForType(type);\n    plural = this.pluralize(root);\n    adapter = this;\n\n    data = {};\n\n    data[plural] = [];\n\n    records.forEach(function(record) {\n      data[plural].push(this.serialize(record, { includeId: true }));\n    }, this);\n\n    return this.ajax(this.buildURL(root, \"bulk\"), \"PUT\", {\n      data: data\n    }).then(function(json) {\n      adapter.didUpdateRecords(store, type, records, json);\n    }).then(null, rejectionHandler);\n  },\n\n  deleteRecord: function(store, type, record) {\n    var id, root, adapter;\n\n    id = get(record, 'id');\n    root = this.rootForType(type);\n    adapter = this;\n\n    return this.ajax(this.buildURL(root, id), \"DELETE\").then(function(json){\n      adapter.didDeleteRecord(store, type, record, json);\n    }, function(xhr){\n      adapter.didError(store, type, record, xhr);\n      throw xhr;\n    }).then(null, rejectionHandler);\n  },\n\n  deleteRecords: function(store, type, records) {\n    var root, plural, serializer, adapter, data;\n\n    if (get(this, 'bulkCommit') === false) {\n      return this._super(store, type, records);\n    }\n\n    root = this.rootForType(type);\n    plural = this.pluralize(root);\n    serializer = get(this, 'serializer');\n    adapter = this;\n\n    data = {};\n\n    data[plural] = [];\n    records.forEach(function(record) {\n      data[plural].push(serializer.serializeId( get(record, 'id') ));\n    });\n\n    return this.ajax(this.buildURL(root, 'bulk'), \"DELETE\", {\n      data: data\n    }).then(function(json){\n      adapter.didDeleteRecords(store, type, records, json);\n    }).then(null, rejectionHandler);\n  },\n\n  find: function(store, type, id) {\n    var root = this.rootForType(type), adapter = this;\n\n    return this.ajax(this.buildURL(root, id), \"GET\").\n      then(function(json){\n        adapter.didFindRecord(store, type, json, id);\n    }).then(null, rejectionHandler);\n  },\n\n  findAll: function(store, type, since) {\n    var root, adapter;\n\n    root = this.rootForType(type);\n    adapter = this;\n\n    return this.ajax(this.buildURL(root), \"GET\",{\n      data: this.sinceQuery(since)\n    }).then(function(json) {\n      adapter.didFindAll(store, type, json);\n    }).then(null, rejectionHandler);\n  },\n\n  findQuery: function(store, type, query, recordArray) {\n    var root = this.rootForType(type),\n    adapter = this;\n\n    return this.ajax(this.buildURL(root), \"GET\", {\n      data: query\n    }).then(function(json){\n      adapter.didFindQuery(store, type, json, recordArray);\n    }).then(null, rejectionHandler);\n  },\n\n  findMany: function(store, type, ids, owner) {\n    var root = this.rootForType(type),\n    adapter = this;\n\n    ids = this.serializeIds(ids);\n\n    return this.ajax(this.buildURL(root), \"GET\", {\n      data: {ids: ids}\n    }).then(function(json) {\n      adapter.didFindMany(store, type, json);\n    }).then(null, rejectionHandler);\n  },\n\n  /**\n    @private\n\n    This method serializes a list of IDs using `serializeId`\n\n    @return {Array} an array of serialized IDs\n  */\n  serializeIds: function(ids) {\n    var serializer = get(this, 'serializer');\n\n    return Ember.EnumerableUtils.map(ids, function(id) {\n      return serializer.serializeId(id);\n    });\n  },\n\n  didError: function(store, type, record, xhr) {\n    if (xhr.status === 422) {\n      var json = JSON.parse(xhr.responseText),\n          serializer = get(this, 'serializer'),\n          errors = serializer.extractValidationErrors(type, json);\n\n      store.recordWasInvalid(record, errors);\n    } else {\n      this._super.apply(this, arguments);\n    }\n  },\n\n  ajax: function(url, type, hash) {\n    var adapter = this;\n\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n      hash = hash || {};\n      hash.url = url;\n      hash.type = type;\n      hash.dataType = 'json';\n      hash.context = adapter;\n\n      if (hash.data && type !== 'GET') {\n        hash.contentType = 'application/json; charset=utf-8';\n        hash.data = JSON.stringify(hash.data);\n      }\n\n      hash.success = function(json) {\n        Ember.run(null, resolve, json);\n      };\n\n      hash.error = function(jqXHR, textStatus, errorThrown) {\n        Ember.run(null, reject, jqXHR);\n      };\n\n      Ember.$.ajax(hash);\n    });\n  },\n\n  url: \"\",\n\n  rootForType: function(type) {\n    var serializer = get(this, 'serializer');\n    return serializer.rootForType(type);\n  },\n\n  pluralize: function(string) {\n    var serializer = get(this, 'serializer');\n    return serializer.pluralize(string);\n  },\n\n  buildURL: function(record, suffix) {\n    var url = [this.url];\n\n    Ember.assert(\"Namespace URL (\" + this.namespace + \") must not start with slash\", !this.namespace || this.namespace.toString().charAt(0) !== \"/\");\n    Ember.assert(\"Record URL (\" + record + \") must not start with slash\", !record || record.toString().charAt(0) !== \"/\");\n    Ember.assert(\"URL suffix (\" + suffix + \") must not start with slash\", !suffix || suffix.toString().charAt(0) !== \"/\");\n\n    if (!Ember.isNone(this.namespace)) {\n      url.push(this.namespace);\n    }\n\n    url.push(this.pluralize(record));\n    if (suffix !== undefined) {\n      url.push(suffix);\n    }\n\n    return url.join(\"/\");\n  },\n\n  sinceQuery: function(since) {\n    var query = {};\n    query[get(this, 'since')] = since;\n    return since ? query : null;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/adapters/rest_adapter");minispade.register('ember-data/core', "(function() {/**\n  @module data\n  @main data\n*/\n\n/**\n  All Ember Data methods and functions are defined inside of this namespace. \n\n  @class DS\n  @static\n*/\n\nwindow.DS = Ember.Namespace.create();\n\n})();\n//@ sourceURL=ember-data/core");minispade.register('ember-data/ext', "(function() {minispade.require('ember-data/ext/date');\n\n})();\n//@ sourceURL=ember-data/ext");minispade.register('ember-data/ext/date', "(function() {/**\n * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n * © 2011 Colin Snover <http://zetafleet.com>\n * Released under MIT license.\n */\n\nEmber.Date = Ember.Date || {};\n\nvar origParse = Date.parse, numericKeys = [ 1, 4, 5, 6, 7, 10, 11 ];\nEmber.Date.parse = function (date) {\n    var timestamp, struct, minutesOffset = 0;\n\n    // ES5 §15.9.4.2 states that the string should attempt to be parsed as a Date Time String Format string\n    // before falling back to any implementation-specific date parsing, so that’s what we do, even if native\n    // implementations could be faster\n    //              1 YYYY                2 MM       3 DD           4 HH    5 mm       6 ss        7 msec        8 Z 9 ±    10 tzHH    11 tzmm\n    if ((struct = /^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/.exec(date))) {\n        // avoid NaN timestamps caused by “undefined” values being passed to Date.UTC\n        for (var i = 0, k; (k = numericKeys[i]); ++i) {\n            struct[k] = +struct[k] || 0;\n        }\n\n        // allow undefined days and months\n        struct[2] = (+struct[2] || 1) - 1;\n        struct[3] = +struct[3] || 1;\n\n        if (struct[8] !== 'Z' && struct[9] !== undefined) {\n            minutesOffset = struct[10] * 60 + struct[11];\n\n            if (struct[9] === '+') {\n                minutesOffset = 0 - minutesOffset;\n            }\n        }\n\n        timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);\n    }\n    else {\n        timestamp = origParse ? origParse(date) : NaN;\n    }\n\n    return timestamp;\n};\n\nif (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Date) {\n  Date.parse = Ember.Date.parse;\n}\n\n})();\n//@ sourceURL=ember-data/ext/date");minispade.register('ember-data/initializers', "(function() {var set = Ember.set;\n\n/**\n  This code registers an injection for Ember.Application.\n\n  If an Ember.js developer defines a subclass of DS.Store on their application,\n  this code will automatically instantiate it and make it available on the\n  router.\n\n  Additionally, after an application's controllers have been injected, they will\n  each have the store made available to them.\n\n  For example, imagine an Ember.js application with the following classes:\n\n  App.Store = DS.Store.extend({\n    adapter: 'App.MyCustomAdapter'\n  });\n\n  App.PostsController = Ember.ArrayController.extend({\n    // ...\n  });\n\n  When the application is initialized, `App.Store` will automatically be\n  instantiated, and the instance of `App.PostsController` will have its `store`\n  property set to that instance.\n\n  Note that this code will only be run if the `ember-application` package is\n  loaded. If Ember Data is being used in an environment other than a\n  typical application (e.g., node.js where only `ember-runtime` is available),\n  this code will be ignored.\n*/\n\nEmber.onLoad('Ember.Application', function(Application) {\n  Application.initializer({\n    name: \"store\",\n\n    initialize: function(container, application) {\n      application.register('store:main', application.Store);\n\n      // Eagerly generate the store so defaultStore is populated.\n      // TODO: Do this in a finisher hook\n      container.lookup('store:main');\n    }\n  });\n\n  Application.initializer({\n    name: \"injectStore\",\n\n    initialize: function(container, application) {\n      application.inject('controller', 'store', 'store:main');\n      application.inject('route', 'store', 'store:main');\n    }\n  });\n});\n\n})();\n//@ sourceURL=ember-data/initializers");minispade.register('ember-data', "(function() {//Copyright (C) 2011 by Living Social, Inc.\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of\n//this software and associated documentation files (the \"Software\"), to deal in\n//the Software without restriction, including without limitation the rights to\n//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n//of the Software, and to permit persons to whom the Software is furnished to do\n//so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n/**\n  Ember Data\n  @module data\n*/\nminispade.require(\"ember-data/core\");\nminispade.require(\"ember-data/initializers\");\nminispade.require(\"ember-data/ext\");\nminispade.require(\"ember-data/system/store\");\nminispade.require(\"ember-data/system/model\");\nminispade.require(\"ember-data/system/changes\");\nminispade.require(\"ember-data/system/relationships\");\nminispade.require(\"ember-data/system/record_arrays\");\nminispade.require(\"ember-data/system/record_array_manager\");\nminispade.require(\"ember-data/system/adapter\");\nminispade.require(\"ember-data/system/serializer\");\nminispade.require(\"ember-data/adapters\");\n\n})();\n//@ sourceURL=ember-data");minispade.register('ember-data/serializers/fixture_serializer', "(function() {minispade.require('ember-data/system/serializer');\n\n/**\n  @module data\n  @submodule data-serializers\n*/\n\n/**\n  @class FixtureSerializer\n  @constructor\n  @namespace DS\n  @extends DS.Serializer\n*/\n\nvar get = Ember.get, set = Ember.set;\n\nDS.FixtureSerializer = DS.Serializer.extend({\n  deserializeValue: function(value, attributeType) {\n    return value;\n  },\n\n  serializeValue: function(value, attributeType) {\n    return value;\n  },\n\n  addId: function(data, key, id) {\n    data[key] = id;\n  },\n\n  addAttribute: function(hash, key, value) {\n    hash[key] = value;\n  },\n\n  addBelongsTo: function(hash, record, key, relationship) {\n    var id = get(record, relationship.key+'.id');\n    if (!Ember.isNone(id)) { hash[key] = id; }\n  },\n\n  addHasMany: function(hash, record, key, relationship) {\n    var ids = get(record, relationship.key).map(function(item) {\n      return item.get('id');\n    });\n\n    hash[relationship.key] = ids;\n  },\n\n  extract: function(loader, fixture, type, record) {\n    if (record) { loader.updateId(record, fixture); }\n    this.extractRecordRepresentation(loader, type, fixture);\n  },\n\n  extractMany: function(loader, fixtures, type, records) {\n    var objects = fixtures, references = [];\n    if (records) { records = records.toArray(); }\n\n    for (var i = 0; i < objects.length; i++) {\n      if (records) { loader.updateId(records[i], objects[i]); }\n      var reference = this.extractRecordRepresentation(loader, type, objects[i]);\n      references.push(reference);\n    }\n\n    loader.populateArray(references);\n  },\n\n  extractId: function(type, hash) {\n    var primaryKey = this._primaryKey(type);\n\n    if (hash.hasOwnProperty(primaryKey)) {\n      // Ensure that we coerce IDs to strings so that record\n      // IDs remain consistent between application runs; especially\n      // if the ID is serialized and later deserialized from the URL,\n      // when type information will have been lost.\n      return hash[primaryKey]+'';\n    } else {\n      return null;\n    }\n  },\n\n  extractAttribute: function(type, hash, attributeName) {\n    var key = this._keyForAttributeName(type, attributeName);\n    return hash[key];\n  },\n\n  extractHasMany: function(type, hash, key) {\n    return hash[key];\n  },\n\n  extractBelongsTo: function(type, hash, key) {\n    var val = hash[key];\n    if (val != null) {\n      val = val + '';\n    }\n    return val;\n  },\n\n  extractBelongsToPolymorphic: function(type, hash, key) {\n    var keyForId = this.keyForPolymorphicId(key),\n        keyForType,\n        id = hash[keyForId];\n\n    if (id) {\n      keyForType = this.keyForPolymorphicType(key);\n      return {id: id, type: hash[keyForType]};\n    }\n\n    return null;\n  },\n\n  keyForPolymorphicId: function(key) {\n    return key;\n  },\n\n  keyForPolymorphicType: function(key) {\n    return key + '_type';\n  }\n});\n\n})();\n//@ sourceURL=ember-data/serializers/fixture_serializer");minispade.register('ember-data/serializers/json_serializer', "(function() {minispade.require('ember-data/system/serializer');\nminispade.require('ember-data/transforms/json_transforms');\n\n/**\n  @module data\n  @submodule data-serializers\n*/\n\n/**\n  @class JSONSerializer\n  @constructor\n  @namespace DS\n  @extends DS.Serializer\n*/\n\nvar get = Ember.get, set = Ember.set;\n\nDS.JSONSerializer = DS.Serializer.extend({\n  init: function() {\n    this._super();\n\n    if (!get(this, 'transforms')) {\n      this.set('transforms', DS.JSONTransforms);\n    }\n\n    this.sideloadMapping = Ember.Map.create();\n    this.metadataMapping = Ember.Map.create();\n\n    this.configure({\n      meta: 'meta',\n      since: 'since'\n    });\n  },\n\n  configure: function(type, configuration) {\n    var key;\n\n    if (type && !configuration) {\n      for(key in type){\n        this.metadataMapping.set(get(type, key), key);\n      }\n\n      return this._super(type);\n    }\n\n    var sideloadAs = configuration.sideloadAs,\n        sideloadMapping;\n\n    if (sideloadAs) {\n      sideloadMapping = this.aliases.sideloadMapping || Ember.Map.create();\n      sideloadMapping.set(sideloadAs, type);\n      this.aliases.sideloadMapping = sideloadMapping;\n      delete configuration.sideloadAs;\n    }\n\n    this._super.apply(this, arguments);\n  },\n\n  addId: function(data, key, id) {\n    data[key] = id;\n  },\n\n  /**\n    A hook you can use to customize how the key/value pair is added to\n    the serialized data.\n\n    @param {any} hash the JSON hash being built\n    @param {String} key the key to add to the serialized data\n    @param {any} value the value to add to the serialized data\n  */\n  addAttribute: function(hash, key, value) {\n    hash[key] = value;\n  },\n\n  extractAttribute: function(type, hash, attributeName) {\n    var key = this._keyForAttributeName(type, attributeName);\n    return hash[key];\n  },\n\n  extractId: function(type, hash) {\n    var primaryKey = this._primaryKey(type);\n\n    if (hash.hasOwnProperty(primaryKey)) {\n      // Ensure that we coerce IDs to strings so that record\n      // IDs remain consistent between application runs; especially\n      // if the ID is serialized and later deserialized from the URL,\n      // when type information will have been lost.\n      return hash[primaryKey]+'';\n    } else {\n      return null;\n    }\n  },\n\n  extractEmbeddedData: function(hash, key) {\n    return hash[key];\n  },\n\n  extractHasMany: function(type, hash, key) {\n    return hash[key];\n  },\n\n  extractBelongsTo: function(type, hash, key) {\n    return hash[key];\n  },\n\n  extractBelongsToPolymorphic: function(type, hash, key) {\n    var keyForId = this.keyForPolymorphicId(key),\n        keyForType,\n        id = hash[keyForId];\n\n    if (id) {\n      keyForType = this.keyForPolymorphicType(key);\n      return {id: id, type: hash[keyForType]};\n    }\n\n    return null;\n  },\n\n  addBelongsTo: function(hash, record, key, relationship) {\n    var type = record.constructor,\n        name = relationship.key,\n        value = null,\n        includeType = (relationship.options && relationship.options.polymorphic),\n        embeddedChild,\n        child,\n        id;\n\n    if (this.embeddedType(type, name)) {\n      if (embeddedChild = get(record, name)) {\n        value = this.serialize(embeddedChild, { includeId: true, includeType: includeType });\n      }\n\n      hash[key] = value;\n    } else {\n      child = get(record, relationship.key);\n      id = get(child, 'id');\n\n      if (relationship.options && relationship.options.polymorphic && !Ember.isNone(id)) {\n        this.addBelongsToPolymorphic(hash, key, id, child.constructor);\n      } else {\n        hash[key] = id === undefined ? null : this.serializeId(id);\n      }\n    }\n  },\n\n  addBelongsToPolymorphic: function(hash, key, id, type) {\n    var keyForId = this.keyForPolymorphicId(key),\n        keyForType = this.keyForPolymorphicType(key);\n    hash[keyForId] = id;\n    hash[keyForType] = this.rootForType(type);\n  },\n\n  /**\n    Adds a has-many relationship to the JSON hash being built.\n\n    The default REST semantics are to only add a has-many relationship if it\n    is embedded. If the relationship was initially loaded by ID, we assume that\n    that was done as a performance optimization, and that changes to the\n    has-many should be saved as foreign key changes on the child's belongs-to\n    relationship.\n\n    @param {Object} hash the JSON being built\n    @param {DS.Model} record the record being serialized\n    @param {String} key the JSON key into which the serialized relationship\n      should be saved\n    @param {Object} relationship metadata about the relationship being serialized\n  */\n\n  addHasMany: function(hash, record, key, relationship) {\n    var type = record.constructor,\n        name = relationship.key,\n        serializedHasMany = [],\n        includeType = (relationship.options && relationship.options.polymorphic),\n        manyArray, embeddedType;\n\n    // If the has-many is not embedded, there is nothing to do.\n    embeddedType = this.embeddedType(type, name);\n    if (embeddedType !== 'always') { return; }\n\n    // Get the DS.ManyArray for the relationship off the record\n    manyArray = get(record, name);\n\n    // Build up the array of serialized records\n    manyArray.forEach(function (record) {\n      serializedHasMany.push(this.serialize(record, { includeId: true, includeType: includeType }));\n    }, this);\n\n    // Set the appropriate property of the serialized JSON to the\n    // array of serialized embedded records\n    hash[key] = serializedHasMany;\n  },\n\n  addType: function(hash, type) {\n    var keyForType = this.keyForEmbeddedType();\n    hash[keyForType] = this.rootForType(type);\n  },\n\n  // EXTRACTION\n\n  extract: function(loader, json, type, record) {\n    var root = this.rootForType(type);\n\n    this.sideload(loader, type, json, root);\n    this.extractMeta(loader, type, json);\n\n    if (json[root]) {\n      if (record) { loader.updateId(record, json[root]); }\n      this.extractRecordRepresentation(loader, type, json[root]);\n    }\n  },\n\n  extractMany: function(loader, json, type, records) {\n    var root = this.rootForType(type);\n    root = this.pluralize(root);\n\n    this.sideload(loader, type, json, root);\n    this.extractMeta(loader, type, json);\n\n    if (json[root]) {\n      var objects = json[root], references = [];\n      if (records) { records = records.toArray(); }\n\n      for (var i = 0; i < objects.length; i++) {\n        if (records) { loader.updateId(records[i], objects[i]); }\n        var reference = this.extractRecordRepresentation(loader, type, objects[i]);\n        references.push(reference);\n      }\n\n      loader.populateArray(references);\n    }\n  },\n\n  extractMeta: function(loader, type, json) {\n    var meta = this.configOption(type, 'meta'),\n        data = json, value;\n\n    if(meta && json[meta]){\n      data = json[meta];\n    }\n\n    this.metadataMapping.forEach(function(property, key){\n      if(value = data[property]){\n        loader.metaForType(type, key, value);\n      }\n    });\n  },\n\n  extractEmbeddedType: function(relationship, data) {\n    var foundType = relationship.type;\n    if(relationship.options && relationship.options.polymorphic) {\n      var key = this.keyFor(relationship),\n          keyForEmbeddedType = this.keyForEmbeddedType(key);\n\n      foundType = this.typeFromAlias(data[keyForEmbeddedType]);\n      delete data[keyForEmbeddedType];\n    }\n\n    return foundType;\n  },\n\n  /**\n    @private\n\n    Iterates over the `json` payload and attempts to load any data\n    included alongside `root`.\n\n    The keys expected for sideloaded data are based upon the types related\n    to the root model. Recursion is used to ensure that types related to\n    related types can be loaded as well. Any custom keys specified by\n    `sideloadAs` mappings will also be respected.\n\n    @param {DS.Store subclass} loader\n    @param {DS.Model subclass} type\n    @param {Object} json\n    @param {String} root\n  */\n  sideload: function(loader, type, json, root) {\n    var sideloadedType;\n\n    this.configureSideloadMappingForType(type);\n\n    for (var prop in json) {\n      if (!json.hasOwnProperty(prop) ||\n          prop === root ||\n          !!this.metadataMapping.get(prop)) {\n        continue;\n      }\n\n      sideloadedType = this.typeFromAlias(prop);\n      Ember.assert(\"Your server returned a hash with the key \" + prop + \" but you have no mapping for it\", !!sideloadedType);\n\n      this.loadValue(loader, sideloadedType, json[prop]);\n    }\n  },\n\n  /**\n    @private\n\n    Configures possible sideload mappings for the types related to a\n    particular model. This recursive method ensures that sideloading\n    works for related models as well.\n\n    @param {DS.Model subclass} type\n    @param {Ember.A} configured an array of types that have already been configured\n  */\n  configureSideloadMappingForType: function(type, configured) {\n    if (!configured) {configured = Ember.A([]);}\n    configured.pushObject(type);\n\n    type.eachRelatedType(function(relatedType) {\n      if (!configured.contains(relatedType)) {\n        var root = this.defaultSideloadRootForType(relatedType);\n        this.aliases.set(root, relatedType);\n\n        this.configureSideloadMappingForType(relatedType, configured);\n      }\n    }, this);\n  },\n\n  loadValue: function(loader, type, value) {\n    if (value instanceof Array) {\n      for (var i=0; i < value.length; i++) {\n        loader.sideload(type, value[i]);\n      }\n    } else {\n      loader.sideload(type, value);\n    }\n  },\n\n  /**\n    A hook you can use in your serializer subclass to customize\n    how a polymorphic association's name is converted into a key for the id.\n\n    @param {String} name the association name to convert into a key\n\n    @return {String} the key\n  */\n  keyForPolymorphicId: function(key){\n    return key;\n  },\n\n  /**\n    A hook you can use in your serializer subclass to customize\n    how a polymorphic association's name is converted into a key for the type.\n\n    @param {String} name the association name to convert into a key\n\n    @return {String} the key\n  */\n  keyForPolymorphicType: function(key){\n    return this.keyForPolymorphicId(key) + '_type';\n  },\n\n  /**\n    A hook you can use in your serializer subclass to customize\n    the key used to store the type of a record of an embedded polymorphic association.\n\n    By default, this method return 'type'.\n\n    @return {String} the key\n  */\n  keyForEmbeddedType: function() {\n    return 'type';\n  },\n\n  // HELPERS\n\n  /**\n    @private\n\n    Determines the singular root name for a particular type.\n\n    This is an underscored, lowercase version of the model name.\n    For example, the type `App.UserGroup` will have the root\n    `user_group`.\n\n    @param {DS.Model subclass} type\n    @return {String} name of the root element\n  */\n  rootForType: function(type) {\n    var typeString = type.toString();\n\n    Ember.assert(\"Your model must not be anonymous. It was \" + type, typeString.charAt(0) !== '(');\n\n    // use the last part of the name as the URL\n    var parts = typeString.split(\".\");\n    var name = parts[parts.length - 1];\n    return name.replace(/([A-Z])/g, '_$1').toLowerCase().slice(1);\n  },\n\n  /**\n    @private\n\n    The default root name for a particular sideloaded type.\n\n    @param {DS.Model subclass} type\n    @return {String} name of the root element\n  */\n  defaultSideloadRootForType: function(type) {\n    return this.pluralize(this.rootForType(type));\n  }\n});\n\n})();\n//@ sourceURL=ember-data/serializers/json_serializer");minispade.register('ember-data/serializers/rest_serializer', "(function() {minispade.require('ember-data/serializers/json_serializer');\n\n/**\n  @module data\n  @submodule data-serializers\n*/\n\n/**\n  @class RESTSerializer\n  @constructor\n  @namespace DS\n  @extends DS.Serializer\n*/\n\nvar get = Ember.get;\n\nDS.RESTSerializer = DS.JSONSerializer.extend({\n  keyForAttributeName: function(type, name) {\n    return Ember.String.decamelize(name);\n  },\n\n  keyForBelongsTo: function(type, name) {\n    var key = this.keyForAttributeName(type, name);\n\n    if (this.embeddedType(type, name)) {\n      return key;\n    }\n\n    return key + \"_id\";\n  },\n\n  keyForHasMany: function(type, name) {\n    var key = this.keyForAttributeName(type, name);\n\n    if (this.embeddedType(type, name)) {\n      return key;\n    }\n\n    return this.singularize(key) + \"_ids\";\n  },\n\n  keyForPolymorphicId: function(key) {\n    return key;\n  },\n\n  keyForPolymorphicType: function(key) {\n    return key.replace(/_id$/, '_type');\n  },\n\n  extractValidationErrors: function(type, json) {\n    var errors = {};\n\n    get(type, 'attributes').forEach(function(name) {\n      var key = this._keyForAttributeName(type, name);\n      if (json['errors'].hasOwnProperty(key)) {\n        errors[name] = json['errors'][key];\n      }\n    }, this);\n\n    return errors;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/serializers/rest_serializer");minispade.register('ember-data/system/adapter', "(function() {minispade.require('ember-data/serializers/json_serializer');\n\n/**\n  @module data\n  @submodule data-adapter\n*/\n\nvar get = Ember.get, set = Ember.set, merge = Ember.merge;\n\nfunction loaderFor(store) {\n  return {\n    load: function(type, data, prematerialized) {\n      return store.load(type, data, prematerialized);\n    },\n\n    loadMany: function(type, array) {\n      return store.loadMany(type, array);\n    },\n\n    updateId: function(record, data) {\n      return store.updateId(record, data);\n    },\n\n    populateArray: Ember.K,\n\n    sideload: function(type, data) {\n      return store.adapterForType(type).load(store, type, data);\n    },\n\n    sideloadMany: function(type, array) {\n      return store.loadMany(type, array);\n    },\n\n    prematerialize: function(reference, prematerialized) {\n      reference.prematerialized = prematerialized;\n    },\n\n    metaForType: function(type, property, data) {\n      store.metaForType(type, property, data);\n    }\n  };\n}\n\nDS.loaderFor = loaderFor;\n\n/**\n  An adapter is an object that receives requests from a store and\n  translates them into the appropriate action to take against your\n  persistence layer. The persistence layer is usually an HTTP API, but may\n  be anything, such as the browser's local storage.\n\n  ### Creating an Adapter\n\n  First, create a new subclass of `DS.Adapter`:\n\n      App.MyAdapter = DS.Adapter.extend({\n        // ...your code here\n      });\n\n  To tell your store which adapter to use, set its `adapter` property:\n\n      App.store = DS.Store.create({\n        adapter: App.MyAdapter.create()\n      });\n\n  `DS.Adapter` is an abstract base class that you should override in your\n  application to customize it for your backend. The minimum set of methods\n  that you should implement is:\n\n    * `find()`\n    * `createRecord()`\n    * `updateRecord()`\n    * `deleteRecord()`\n\n  To improve the network performance of your application, you can optimize\n  your adapter by overriding these lower-level methods:\n\n    * `findMany()`\n    * `createRecords()`\n    * `updateRecords()`\n    * `deleteRecords()`\n    * `commit()`\n\n  For an example implementation, see {{#crossLink \"DS.RestAdapter\"}} the\n  included REST adapter.{{/crossLink}}.\n  \n  @class Adapter\n  @namespace DS\n  @extends Ember.Object\n*/\n\nDS.Adapter = Ember.Object.extend(DS._Mappable, {\n\n  init: function() {\n    var serializer = get(this, 'serializer');\n\n    if (Ember.Object.detect(serializer)) {\n      serializer = serializer.create();\n      set(this, 'serializer', serializer);\n    }\n\n    this._attributesMap = this.createInstanceMapFor('attributes');\n    this._configurationsMap = this.createInstanceMapFor('configurations');\n\n    this._outstandingOperations = new Ember.MapWithDefault({\n      defaultValue: function() { return 0; }\n    });\n\n    this._dependencies = new Ember.MapWithDefault({\n      defaultValue: function() { return new Ember.OrderedSet(); }\n    });\n\n    this.registerSerializerTransforms(this.constructor, serializer, {});\n    this.registerSerializerMappings(serializer);\n  },\n\n  /**\n    Loads a payload for a record into the store.\n\n    This method asks the serializer to break the payload into\n    constituent parts, and then loads them into the store. For example,\n    if you have a payload that contains embedded records, they will be\n    extracted by the serializer and loaded into the store.\n\n    For example:\n\n        adapter.load(store, App.Person, {\n          id: 123,\n          firstName: \"Yehuda\",\n          lastName: \"Katz\",\n          occupations: [{\n            id: 345,\n            title: \"Tricycle Mechanic\"\n          }]\n        });\n\n    This will load the payload for the `App.Person` with ID `123` and\n    the embedded `App.Occupation` with ID `345`.\n\n    @method load\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {any} payload\n  */\n  load: function(store, type, payload) {\n    var loader = loaderFor(store);\n    return get(this, 'serializer').extractRecordRepresentation(loader, type, payload);\n  },\n\n  /**\n    Acknowledges that the adapter has finished creating a record.\n\n    Your adapter should call this method from `createRecord` when\n    it has saved a new record to its persistent storage and received\n    an acknowledgement.\n\n    If the persistent storage returns a new payload in response to the\n    creation, and you want to update the existing record with the\n    new information, pass the payload as the fourth parameter.\n\n    For example, the `RESTAdapter` saves newly created records by\n    making an Ajax request. When the server returns, the adapter\n    calls didCreateRecord. If the server returns a response body,\n    it is passed as the payload.\n\n    @method didCreateRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @param {any} payload\n  */\n  didCreateRecord: function(store, type, record, payload) {\n    store.didSaveRecord(record);\n\n    if (payload) {\n      var loader = DS.loaderFor(store);\n\n      loader.load = function(type, data, prematerialized) {\n        store.updateId(record, data);\n        return store.load(type, data, prematerialized);\n      };\n\n      get(this, 'serializer').extract(loader, payload, type);\n    }\n  },\n\n  /**\n    Acknowledges that the adapter has finished creating several records.\n\n    Your adapter should call this method from `createRecords` when it\n    has saved multiple created records to its persistent storage\n    received an acknowledgement.\n\n    If the persistent storage returns a new payload in response to the\n    creation, and you want to update the existing record with the\n    new information, pass the payload as the fourth parameter.\n\n    @method didCreateRecords\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @param {any} payload\n  */\n  didCreateRecords: function(store, type, records, payload) {\n    records.forEach(function(record) {\n      store.didSaveRecord(record);\n    }, this);\n\n    if (payload) {\n      var loader = DS.loaderFor(store);\n      get(this, 'serializer').extractMany(loader, payload, type, records);\n    }\n  },\n\n  /**\n    @private\n\n    Acknowledges that the adapter has finished updating or deleting a record.\n\n    Your adapter should call this method from `updateRecord` or `deleteRecord`\n    when it has updated or deleted a record to its persistent storage and\n    received an acknowledgement.\n\n    If the persistent storage returns a new payload in response to the\n    update or delete, and you want to update the existing record with the\n    new information, pass the payload as the fourth parameter.\n\n    @method didSaveRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @param {any} payload\n  */\n  didSaveRecord: function(store, type, record, payload) {\n    store.didSaveRecord(record);\n\n    var serializer = get(this, 'serializer');\n\n    serializer.eachEmbeddedRecord(record, function(embeddedRecord, embeddedType) {\n      if (embeddedType === 'load') { return; }\n\n      this.didSaveRecord(store, embeddedRecord.constructor, embeddedRecord);\n    }, this);\n\n    if (payload) {\n      var loader = DS.loaderFor(store);\n      serializer.extract(loader, payload, type);\n    }\n  },\n\n  /**\n    Acknowledges that the adapter has finished updating a record.\n\n    Your adapter should call this method from `updateRecord` when it\n    has updated a record to its persistent storage and received an\n    acknowledgement.\n\n    If the persistent storage returns a new payload in response to the\n    update, pass the payload as the fourth parameter.\n\n    @method didUpdateRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @param {any} payload\n  */\n  didUpdateRecord: function() {\n    this.didSaveRecord.apply(this, arguments);\n  },\n\n  /**\n    Acknowledges that the adapter has finished deleting a record.\n\n    Your adapter should call this method from `deleteRecord` when it\n    has deleted a record from its persistent storage and received an\n    acknowledgement.\n\n    If the persistent storage returns a new payload in response to the\n    deletion, pass the payload as the fourth parameter.\n\n    @method didDeleteRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @param {any} payload\n  */\n  didDeleteRecord: function() {\n    this.didSaveRecord.apply(this, arguments);\n  },\n\n  /**\n    Acknowledges that the adapter has finished updating or deleting\n    multiple records.\n\n    Your adapter should call this method from its `updateRecords` or\n    `deleteRecords` when it has updated or deleted multiple records\n    to its persistent storage and received an acknowledgement.\n\n    If the persistent storage returns a new payload in response to the\n    creation, pass the payload as the fourth parameter.\n\n    @method didSaveRecords\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} records\n    @param {any} payload\n  */\n  didSaveRecords: function(store, type, records, payload) {\n    records.forEach(function(record) {\n      store.didSaveRecord(record);\n    }, this);\n\n    if (payload) {\n      var loader = DS.loaderFor(store);\n      get(this, 'serializer').extractMany(loader, payload, type);\n    }\n  },\n\n  /**\n    Acknowledges that the adapter has finished updating multiple records.\n\n    Your adapter should call this method from its `updateRecords` when\n    it has updated multiple records to its persistent storage and\n    received an acknowledgement.\n\n    If the persistent storage returns a new payload in response to the\n    update, pass the payload as the fourth parameter.\n\n    @method didUpdateRecords\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} records\n    @param {any} payload\n  */\n  didUpdateRecords: function() {\n    this.didSaveRecords.apply(this, arguments);\n  },\n\n  /**\n    Acknowledges that the adapter has finished updating multiple records.\n\n    Your adapter should call this method from its `deleteRecords` when\n    it has deleted multiple records to its persistent storage and\n    received an acknowledgement.\n\n    If the persistent storage returns a new payload in response to the\n    deletion, pass the payload as the fourth parameter.\n\n    @method didDeleteRecords\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} records\n    @param {any} payload\n  */\n  didDeleteRecords: function() {\n    this.didSaveRecords.apply(this, arguments);\n  },\n\n  /**\n    Loads the response to a request for a record by ID.\n\n    Your adapter should call this method from its `find` method\n    with the response from the backend.\n\n    You should pass the same ID to this method that was given\n    to your find method so that the store knows which record\n    to associate the new data with.\n\n    @method didFindRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {any} payload\n    @param {String} id\n  */\n  didFindRecord: function(store, type, payload, id) {\n    var loader = DS.loaderFor(store);\n\n    loader.load = function(type, data, prematerialized) {\n      prematerialized = prematerialized || {};\n      prematerialized.id = id;\n\n      return store.load(type, data, prematerialized);\n    };\n\n    get(this, 'serializer').extract(loader, payload, type);\n  },\n\n  /**\n    Loads the response to a request for all records by type.\n\n    You adapter should call this method from its `findAll`\n    method with the response from the backend.\n\n    @method didFindAll\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {any} payload\n  */\n  didFindAll: function(store, type, payload) {\n    var loader = DS.loaderFor(store),\n        serializer = get(this, 'serializer');\n\n    store.didUpdateAll(type);\n\n    serializer.extractMany(loader, payload, type);\n  },\n\n  /**\n    Loads the response to a request for records by query.\n\n    Your adapter should call this method from its `findQuery`\n    method with the response from the backend.\n\n    @method didFindQuery\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {any} payload\n    @param {DS.AdapterPopulatedRecordArray} recordArray\n  */\n  didFindQuery: function(store, type, payload, recordArray) {\n    var loader = DS.loaderFor(store);\n\n    loader.populateArray = function(data) {\n      recordArray.load(data);\n    };\n\n    get(this, 'serializer').extractMany(loader, payload, type);\n  },\n\n  /**\n    Loads the response to a request for many records by ID.\n\n    You adapter should call this method from its `findMany`\n    method with the response from the backend.\n\n    @method didFindMany\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {any} payload\n  */\n  didFindMany: function(store, type, payload) {\n    var loader = DS.loaderFor(store);\n\n    get(this, 'serializer').extractMany(loader, payload, type);\n  },\n\n  /**\n    Notifies the store that a request to the backend returned\n    an error.\n\n    Your adapter should call this method to indicate that the\n    backend returned an error for a request.\n\n    @method didError\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n  */\n  didError: function(store, type, record) {\n    store.recordWasError(record);\n  },\n\n  dirtyRecordsForAttributeChange: function(dirtySet, record, attributeName, newValue, oldValue) {\n    if (newValue !== oldValue) {\n      // If this record is embedded, add its parent\n      // to the dirty set.\n      this.dirtyRecordsForRecordChange(dirtySet, record);\n    }\n  },\n\n  dirtyRecordsForRecordChange: function(dirtySet, record) {\n    dirtySet.add(record);\n  },\n\n  dirtyRecordsForBelongsToChange: function(dirtySet, child) {\n    this.dirtyRecordsForRecordChange(dirtySet, child);\n  },\n\n  dirtyRecordsForHasManyChange: function(dirtySet, parent) {\n    this.dirtyRecordsForRecordChange(dirtySet, parent);\n  },\n\n  /**\n    @private\n\n    This method recursively climbs the superclass hierarchy and\n    registers any class-registered transforms on the adapter's\n    serializer.\n\n    Once it registers a transform for a given type, it ignores\n    subsequent transforms for the same attribute type.\n\n    @method registerSerializerTransforms\n    @param {Class} klass the DS.Adapter subclass to extract the\n      transforms from\n    @param {DS.Serializer} serializer the serializer to register\n      the transforms onto\n    @param {Object} seen a hash of attributes already seen\n  */\n  registerSerializerTransforms: function(klass, serializer, seen) {\n    var transforms = klass._registeredTransforms, superclass, prop;\n    var enumTransforms = klass._registeredEnumTransforms;\n\n    for (prop in transforms) {\n      if (!transforms.hasOwnProperty(prop) || prop in seen) { continue; }\n      seen[prop] = true;\n\n      serializer.registerTransform(prop, transforms[prop]);\n    }\n\n    for (prop in enumTransforms) {\n      if (!enumTransforms.hasOwnProperty(prop) || prop in seen) { continue; }\n      seen[prop] = true;\n\n      serializer.registerEnumTransform(prop, enumTransforms[prop]);\n    }\n\n    if (superclass = klass.superclass) {\n      this.registerSerializerTransforms(superclass, serializer, seen);\n    }\n  },\n\n  /**\n    @private\n\n    This method recursively climbs the superclass hierarchy and\n    registers any class-registered mappings on the adapter's\n    serializer.\n\n    @method registerSerializerMappings\n    @param {Class} klass the DS.Adapter subclass to extract the\n      transforms from\n    @param {DS.Serializer} serializer the serializer to register the\n      mappings onto\n  */\n  registerSerializerMappings: function(serializer) {\n    var mappings = this._attributesMap,\n        configurations = this._configurationsMap;\n\n    mappings.forEach(serializer.map, serializer);\n    configurations.forEach(serializer.configure, serializer);\n  },\n\n  /**\n    The `find()` method is invoked when the store is asked for a record that\n    has not previously been loaded. In response to `find()` being called, you\n    should query your persistence layer for a record with the given ID. Once\n    found, you can asynchronously call the store's `load()` method to load\n    the record.\n\n    Here is an example `find` implementation:\n\n        find: function(store, type, id) {\n          var url = type.url;\n          url = url.fmt(id);\n\n          jQuery.getJSON(url, function(data) {\n              // data is a hash of key/value pairs. If your server returns a\n              // root, simply do something like:\n              // store.load(type, id, data.person)\n              store.load(type, id, data);\n          });\n        }\n\n    @method find\n  */\n  find: null,\n\n  serializer: DS.JSONSerializer,\n\n  registerTransform: function(attributeType, transform) {\n    get(this, 'serializer').registerTransform(attributeType, transform);\n  },\n\n  /**\n    A public method that allows you to register an enumerated\n    type on your adapter.  This is useful if you want to utilize\n    a text representation of an integer value.\n\n    Eg: Say you want to utilize \"low\",\"medium\",\"high\" text strings\n    in your app, but you want to persist those as 0,1,2 in your backend.\n    You would first register the transform on your adapter instance:\n\n        adapter.registerEnumTransform('priority', ['low', 'medium', 'high']);\n\n    You would then refer to the 'priority' DS.attr in your model:\n\n        App.Task = DS.Model.extend({\n          priority: DS.attr('priority')\n        });\n\n    And lastly, you would set/get the text representation on your model instance,\n    but the transformed result will be the index number of the type.\n\n        App:   myTask.get('priority') => 'low'\n        Server Response / Load:  { myTask: {priority: 0} }\n\n    @method registerEnumTransform\n    @param {String} type of the transform\n    @param {Array} array of String objects to use for the enumerated values.\n      This is an ordered list and the index values will be used for the transform.\n  */\n  registerEnumTransform: function(attributeType, objects) {\n    get(this, 'serializer').registerEnumTransform(attributeType, objects);\n  },\n\n  /**\n    If the globally unique IDs for your records should be generated on the client,\n    implement the `generateIdForRecord()` method. This method will be invoked\n    each time you create a new record, and the value returned from it will be\n    assigned to the record's `primaryKey`.\n\n    Most traditional REST-like HTTP APIs will not use this method. Instead, the ID\n    of the record will be set by the server, and your adapter will update the store\n    with the new ID when it calls `didCreateRecord()`. Only implement this method if\n    you intend to generate record IDs on the client-side.\n\n    The `generateIdForRecord()` method will be invoked with the requesting store as\n    the first parameter and the newly created record as the second parameter:\n\n        generateIdForRecord: function(store, record) {\n          var uuid = App.generateUUIDWithStatisticallyLowOddsOfCollision();\n          return uuid;\n        }\n\n    @method generateIdForRecord\n    @param {DS.Store} store\n    @param {DS.Model} record\n  */\n  generateIdForRecord: null,\n\n  materialize: function(record, data, prematerialized) {\n    get(this, 'serializer').materialize(record, data, prematerialized);\n  },\n\n  serialize: function(record, options) {\n    return get(this, 'serializer').serialize(record, options);\n  },\n\n  extractId: function(type, data) {\n    return get(this, 'serializer').extractId(type, data);\n  },\n\n  groupByType: function(enumerable) {\n    var map = Ember.MapWithDefault.create({\n      defaultValue: function() { return Ember.OrderedSet.create(); }\n    });\n\n    enumerable.forEach(function(item) {\n      map.get(item.constructor).add(item);\n    });\n\n    return map;\n  },\n\n  commit: function(store, commitDetails) {\n    this.save(store, commitDetails);\n  },\n\n  save: function(store, commitDetails) {\n    var adapter = this;\n\n    function filter(records) {\n      var filteredSet = Ember.OrderedSet.create();\n\n      records.forEach(function(record) {\n        if (adapter.shouldSave(record)) {\n          filteredSet.add(record);\n        }\n      });\n\n      return filteredSet;\n    }\n\n    this.groupByType(commitDetails.created).forEach(function(type, set) {\n      this.createRecords(store, type, filter(set));\n    }, this);\n\n    this.groupByType(commitDetails.updated).forEach(function(type, set) {\n      this.updateRecords(store, type, filter(set));\n    }, this);\n\n    this.groupByType(commitDetails.deleted).forEach(function(type, set) {\n      this.deleteRecords(store, type, filter(set));\n    }, this);\n  },\n\n  shouldSave: Ember.K,\n\n  createRecords: function(store, type, records) {\n    records.forEach(function(record) {\n      this.createRecord(store, type, record);\n    }, this);\n  },\n\n  updateRecords: function(store, type, records) {\n    records.forEach(function(record) {\n      this.updateRecord(store, type, record);\n    }, this);\n  },\n\n  deleteRecords: function(store, type, records) {\n    records.forEach(function(record) {\n      this.deleteRecord(store, type, record);\n    }, this);\n  },\n\n  findMany: function(store, type, ids) {\n    ids.forEach(function(id) {\n      this.find(store, type, id);\n    }, this);\n  }\n});\n\nDS.Adapter.reopenClass({\n  registerTransform: function(attributeType, transform) {\n    var registeredTransforms = this._registeredTransforms || {};\n\n    registeredTransforms[attributeType] = transform;\n\n    this._registeredTransforms = registeredTransforms;\n  },\n\n  registerEnumTransform: function(attributeType, objects) {\n    var registeredEnumTransforms = this._registeredEnumTransforms || {};\n\n    registeredEnumTransforms[attributeType] = objects;\n\n    this._registeredEnumTransforms = registeredEnumTransforms;\n  },\n\n  map: DS._Mappable.generateMapFunctionFor('attributes', function(key, newValue, map) {\n    var existingValue = map.get(key);\n\n    merge(existingValue, newValue);\n  }),\n\n  configure: DS._Mappable.generateMapFunctionFor('configurations', function(key, newValue, map) {\n    var existingValue = map.get(key);\n\n    // If a mapping configuration is provided, peel it off and apply it\n    // using the DS.Adapter.map API.\n    var mappings = newValue && newValue.mappings;\n    if (mappings) {\n      this.map(key, mappings);\n      delete newValue.mappings;\n    }\n\n    merge(existingValue, newValue);\n  }),\n\n  resolveMapConflict: function(oldValue, newValue) {\n    merge(newValue, oldValue);\n\n    return newValue;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/adapter");minispade.register('ember-data/system/changes', "(function() {/**\n  @module data\n  @submodule data-changes\n*/\nminispade.require(\"ember-data/system/changes/attribute_change\");\nminispade.require(\"ember-data/system/changes/relationship_change\");\n\n})();\n//@ sourceURL=ember-data/system/changes");minispade.register('ember-data/system/changes/attribute_change', "(function() {/**\n  An AttributeChange object is created whenever a record's\n  attribute changes value. It is used to track changes to a\n  record between transaction commits.\n*/\n\nvar AttributeChange = DS.AttributeChange = function(options) {\n  this.reference = options.reference;\n  this.store = options.store;\n  this.name = options.name;\n  this.oldValue = options.oldValue;\n};\n\nAttributeChange.createChange = function(options) {\n  return new AttributeChange(options);\n};\n\nAttributeChange.prototype = {\n  sync: function() {\n    this.store.recordAttributeDidChange(this.reference, this.name, this.value, this.oldValue);\n\n    // TODO: Use this object in the commit process\n    this.destroy();\n  },\n\n  /**\n   If the AttributeChange is destroyed (either by being rolled back\n   or being committed), remove it from the list of pending changes\n   on the record.\n  */\n  destroy: function() {\n    var record = this.reference.record;\n\n    delete record._changesToSync[this.name];\n  }\n};\n\n})();\n//@ sourceURL=ember-data/system/changes/attribute_change");minispade.register('ember-data/system/changes/relationship_change', "(function() {var get = Ember.get, set = Ember.set;\nvar forEach = Ember.EnumerableUtils.forEach;\n\nDS.RelationshipChange = function(options) {\n  this.parentReference = options.parentReference;\n  this.childReference = options.childReference;\n  this.firstRecordReference = options.firstRecordReference;\n  this.firstRecordKind = options.firstRecordKind;\n  this.firstRecordName = options.firstRecordName;\n  this.secondRecordReference = options.secondRecordReference;\n  this.secondRecordKind = options.secondRecordKind;\n  this.secondRecordName = options.secondRecordName;\n  this.changeType = options.changeType;\n  this.store = options.store;\n\n  this.committed = {};\n};\n\nDS.RelationshipChangeAdd = function(options){\n  DS.RelationshipChange.call(this, options);\n};\n\nDS.RelationshipChangeRemove = function(options){\n  DS.RelationshipChange.call(this, options);\n};\n\n/** @private */\nDS.RelationshipChange.create = function(options) {\n  return new DS.RelationshipChange(options);\n};\n\n/** @private */\nDS.RelationshipChangeAdd.create = function(options) {\n  return new DS.RelationshipChangeAdd(options);\n};\n\n/** @private */\nDS.RelationshipChangeRemove.create = function(options) {\n  return new DS.RelationshipChangeRemove(options);\n};\n\nDS.OneToManyChange = {};\nDS.OneToNoneChange = {};\nDS.ManyToNoneChange = {};\nDS.OneToOneChange = {};\nDS.ManyToManyChange = {};\n\nDS.RelationshipChange._createChange = function(options){\n  if(options.changeType === \"add\"){\n    return DS.RelationshipChangeAdd.create(options);\n  }\n  if(options.changeType === \"remove\"){\n    return DS.RelationshipChangeRemove.create(options);\n  }\n};\n\n\nDS.RelationshipChange.determineRelationshipType = function(recordType, knownSide){\n  var knownKey = knownSide.key, key, otherKind;\n  var knownKind = knownSide.kind;\n\n  var inverse = recordType.inverseFor(knownKey);\n\n  if (inverse){\n    key = inverse.name;\n    otherKind = inverse.kind;\n  }\n\n  if (!inverse){\n    return knownKind === \"belongsTo\" ? \"oneToNone\" : \"manyToNone\";\n  }\n  else{\n    if(otherKind === \"belongsTo\"){\n      return knownKind === \"belongsTo\" ? \"oneToOne\" : \"manyToOne\";\n    }\n    else{\n      return knownKind === \"belongsTo\" ? \"oneToMany\" : \"manyToMany\";\n    }\n  } \n \n};\n\nDS.RelationshipChange.createChange = function(firstRecordReference, secondRecordReference, store, options){\n  // Get the type of the child based on the child's client ID\n  var firstRecordType = firstRecordReference.type, changeType;\n  changeType = DS.RelationshipChange.determineRelationshipType(firstRecordType, options);\n  if (changeType === \"oneToMany\"){\n    return DS.OneToManyChange.createChange(firstRecordReference, secondRecordReference, store, options);\n  }\n  else if (changeType === \"manyToOne\"){\n    return DS.OneToManyChange.createChange(secondRecordReference, firstRecordReference, store, options);\n  }\n  else if (changeType === \"oneToNone\"){\n    return DS.OneToNoneChange.createChange(firstRecordReference, secondRecordReference, store, options);\n  }\n  else if (changeType === \"manyToNone\"){\n    return DS.ManyToNoneChange.createChange(firstRecordReference, secondRecordReference, store, options);\n  }\n  else if (changeType === \"oneToOne\"){\n    return DS.OneToOneChange.createChange(firstRecordReference, secondRecordReference, store, options);\n  }\n  else if (changeType === \"manyToMany\"){\n    return DS.ManyToManyChange.createChange(firstRecordReference, secondRecordReference, store, options);\n  }\n};\n\n/** @private */\nDS.OneToNoneChange.createChange = function(childReference, parentReference, store, options) {\n  var key = options.key;\n  var change = DS.RelationshipChange._createChange({\n      parentReference: parentReference,\n      childReference: childReference,\n      firstRecordReference: childReference,\n      store: store,\n      changeType: options.changeType,\n      firstRecordName: key,\n      firstRecordKind: \"belongsTo\"\n  });\n\n  store.addRelationshipChangeFor(childReference, key, parentReference, null, change);\n\n  return change;\n};\n\n/** @private */\nDS.ManyToNoneChange.createChange = function(childReference, parentReference, store, options) {\n  var key = options.key;\n  var change = DS.RelationshipChange._createChange({\n      parentReference: childReference,\n      childReference: parentReference,\n      secondRecordReference: childReference,\n      store: store,\n      changeType: options.changeType,\n      secondRecordName: options.key,\n      secondRecordKind: \"hasMany\"\n  });\n\n  store.addRelationshipChangeFor(childReference, key, parentReference, null, change);\n  return change;\n};\n\n\n/** @private */\nDS.ManyToManyChange.createChange = function(childReference, parentReference, store, options) {\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  var key = options.key;\n\n  var change = DS.RelationshipChange._createChange({\n      parentReference: parentReference,\n      childReference: childReference,\n      firstRecordReference: childReference,\n      secondRecordReference: parentReference,\n      firstRecordKind: \"hasMany\",\n      secondRecordKind: \"hasMany\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childReference, key, parentReference, null, change);\n\n\n  return change;\n};\n\n/** @private */\nDS.OneToOneChange.createChange = function(childReference, parentReference, store, options) {\n  var key;\n\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  if (options.parentType) {\n    key = options.parentType.inverseFor(options.key).name;\n  } else if (options.key) {\n    key = options.key;\n  } else {\n    Ember.assert(\"You must pass either a parentType or belongsToName option to OneToManyChange.forChildAndParent\", false);\n  }\n\n  var change = DS.RelationshipChange._createChange({\n      parentReference: parentReference,\n      childReference: childReference,\n      firstRecordReference: childReference,\n      secondRecordReference: parentReference,\n      firstRecordKind: \"belongsTo\",\n      secondRecordKind: \"belongsTo\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childReference, key, parentReference, null, change);\n\n\n  return change;\n};\n\nDS.OneToOneChange.maintainInvariant = function(options, store, childReference, key){\n  if (options.changeType === \"add\" && store.recordIsMaterialized(childReference)) {\n    var child = store.recordForReference(childReference);\n    var oldParent = get(child, key);\n    if (oldParent){\n      var correspondingChange = DS.OneToOneChange.createChange(childReference, oldParent.get('_reference'), store, {\n          parentType: options.parentType,\n          hasManyName: options.hasManyName,\n          changeType: \"remove\",\n          key: options.key\n        });\n      store.addRelationshipChangeFor(childReference, key, options.parentReference , null, correspondingChange);\n     correspondingChange.sync();\n    }\n  }\n};\n\n/** @private */\nDS.OneToManyChange.createChange = function(childReference, parentReference, store, options) {\n  var key;\n\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  if (options.parentType) {\n    key = options.parentType.inverseFor(options.key).name;\n    DS.OneToManyChange.maintainInvariant( options, store, childReference, key );\n  } else if (options.key) {\n    key = options.key;\n  } else {\n    Ember.assert(\"You must pass either a parentType or belongsToName option to OneToManyChange.forChildAndParent\", false);\n  }\n\n  var change = DS.RelationshipChange._createChange({\n      parentReference: parentReference,\n      childReference: childReference,\n      firstRecordReference: childReference,\n      secondRecordReference: parentReference,\n      firstRecordKind: \"belongsTo\",\n      secondRecordKind: \"hasMany\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childReference, key, parentReference, change.getSecondRecordName(), change);\n\n\n  return change;\n};\n\n\nDS.OneToManyChange.maintainInvariant = function(options, store, childReference, key){\n  var child = childReference.record;\n\n  if (options.changeType === \"add\" && child) {\n    var oldParent = get(child, key);\n    if (oldParent){\n      var correspondingChange = DS.OneToManyChange.createChange(childReference, oldParent.get('_reference'), store, {\n          parentType: options.parentType,\n          hasManyName: options.hasManyName,\n          changeType: \"remove\",\n          key: options.key\n        });\n      store.addRelationshipChangeFor(childReference, key, options.parentReference, correspondingChange.getSecondRecordName(), correspondingChange);\n      correspondingChange.sync();\n    }\n  }\n};\n\nDS.OneToManyChange.ensureSameTransaction = function(changes){\n  var records = Ember.A();\n  forEach(changes, function(change){\n    records.addObject(change.getSecondRecord());\n    records.addObject(change.getFirstRecord());\n  });\n\n  return DS.Transaction.ensureSameTransaction(records);\n};\n\nDS.RelationshipChange.prototype = {\n\n  getSecondRecordName: function() {\n    var name = this.secondRecordName, parent;\n\n    if (!name) {\n      parent = this.secondRecordReference;\n      if (!parent) { return; }\n\n      var childType = this.firstRecordReference.type;\n      var inverse = childType.inverseFor(this.firstRecordName);\n      this.secondRecordName = inverse.name;\n    }\n\n    return this.secondRecordName;\n  },\n\n  /**\n    Get the name of the relationship on the belongsTo side.\n\n    @return {String}\n  */\n  getFirstRecordName: function() {\n    var name = this.firstRecordName;\n    return name;\n  },\n\n  /** @private */\n  destroy: function() {\n    var childReference = this.childReference,\n        belongsToName = this.getFirstRecordName(),\n        hasManyName = this.getSecondRecordName(),\n        store = this.store;\n\n    store.removeRelationshipChangeFor(childReference, belongsToName, this.parentReference, hasManyName, this.changeType);\n  },\n\n  /** @private */\n  getByReference: function(reference) {\n    var store = this.store;\n\n    // return null or undefined if the original reference was null or undefined\n    if (!reference) { return reference; }\n\n    if (reference.record) {\n      return reference.record;\n    }\n  },\n\n  getSecondRecord: function(){\n    return this.getByReference(this.secondRecordReference);\n  },\n\n  /** @private */\n  getFirstRecord: function() {\n    return this.getByReference(this.firstRecordReference);\n  },\n\n  /**\n    @private\n\n    Make sure that all three parts of the relationship change are part of\n    the same transaction. If any of the three records is clean and in the\n    default transaction, and the rest are in a different transaction, move\n    them all into that transaction.\n  */\n  ensureSameTransaction: function() {\n    var child = this.getFirstRecord(),\n      parentRecord = this.getSecondRecord();\n\n    var transaction = DS.Transaction.ensureSameTransaction([child, parentRecord]);\n\n    this.transaction = transaction;\n    return transaction;\n  },\n\n  callChangeEvents: function(){\n    var child = this.getFirstRecord(),\n        parentRecord = this.getSecondRecord();\n\n    var dirtySet = new Ember.OrderedSet();\n\n    // TODO: This implementation causes a race condition in key-value\n    // stores. The fix involves buffering changes that happen while\n    // a record is loading. A similar fix is required for other parts\n    // of ember-data, and should be done as new infrastructure, not\n    // a one-off hack. [tomhuda]\n    if (parentRecord && get(parentRecord, 'isLoaded')) {\n      this.store.recordHasManyDidChange(dirtySet, parentRecord, this);\n    }\n\n    if (child) {\n      this.store.recordBelongsToDidChange(dirtySet, child, this);\n    }\n\n    dirtySet.forEach(function(record) {\n      record.adapterDidDirty();\n    });\n  },\n\n  coalesce: function(){\n    var relationshipPairs = this.store.relationshipChangePairsFor(this.firstRecordReference);\n    forEach(relationshipPairs, function(pair){\n      var addedChange = pair[\"add\"];\n      var removedChange = pair[\"remove\"];\n      if(addedChange && removedChange) {\n        addedChange.destroy();\n        removedChange.destroy();\n      }\n    });\n  }\n};\n\nDS.RelationshipChangeAdd.prototype = Ember.create(DS.RelationshipChange.create({}));\nDS.RelationshipChangeRemove.prototype = Ember.create(DS.RelationshipChange.create({}));\n\nDS.RelationshipChangeAdd.prototype.changeType = \"add\";\nDS.RelationshipChangeAdd.prototype.sync = function() {\n  var secondRecordName = this.getSecondRecordName(),\n      firstRecordName = this.getFirstRecordName(),\n      firstRecord = this.getFirstRecord(),\n      secondRecord = this.getSecondRecord();\n\n  //Ember.assert(\"You specified a hasMany (\" + hasManyName + \") on \" + (!belongsToName && (newParent || oldParent || this.lastParent).constructor) + \" but did not specify an inverse belongsTo on \" + child.constructor, belongsToName);\n  //Ember.assert(\"You specified a belongsTo (\" + belongsToName + \") on \" + child.constructor + \" but did not specify an inverse hasMany on \" + (!hasManyName && (newParent || oldParent || this.lastParentRecord).constructor), hasManyName);\n\n  this.ensureSameTransaction();\n\n  this.callChangeEvents();\n\n  if (secondRecord && firstRecord) {\n    if(this.secondRecordKind === \"belongsTo\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        set(secondRecord, secondRecordName, firstRecord);\n      });\n\n     }\n     else if(this.secondRecordKind === \"hasMany\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        get(secondRecord, secondRecordName).addObject(firstRecord);\n      });\n    }\n  }\n\n  if (firstRecord && secondRecord && get(firstRecord, firstRecordName) !== secondRecord) {\n    if(this.firstRecordKind === \"belongsTo\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        set(firstRecord, firstRecordName, secondRecord);\n      });\n    }\n    else if(this.firstRecordKind === \"hasMany\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        get(firstRecord, firstRecordName).addObject(secondRecord);\n      });\n    }\n  }\n\n  this.coalesce();\n};\n\nDS.RelationshipChangeRemove.prototype.changeType = \"remove\";\nDS.RelationshipChangeRemove.prototype.sync = function() {\n  var secondRecordName = this.getSecondRecordName(),\n      firstRecordName = this.getFirstRecordName(),\n      firstRecord = this.getFirstRecord(),\n      secondRecord = this.getSecondRecord();\n\n  //Ember.assert(\"You specified a hasMany (\" + hasManyName + \") on \" + (!belongsToName && (newParent || oldParent || this.lastParent).constructor) + \" but did not specify an inverse belongsTo on \" + child.constructor, belongsToName);\n  //Ember.assert(\"You specified a belongsTo (\" + belongsToName + \") on \" + child.constructor + \" but did not specify an inverse hasMany on \" + (!hasManyName && (newParent || oldParent || this.lastParentRecord).constructor), hasManyName);\n\n  this.ensureSameTransaction(firstRecord, secondRecord, secondRecordName, firstRecordName);\n\n  this.callChangeEvents();\n\n  if (secondRecord && firstRecord) {\n    if(this.secondRecordKind === \"belongsTo\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        set(secondRecord, secondRecordName, null);\n      });\n     }\n     else if(this.secondRecordKind === \"hasMany\"){\n       secondRecord.suspendRelationshipObservers(function(){\n        get(secondRecord, secondRecordName).removeObject(firstRecord);\n      });\n    }\n  }\n\n  if (firstRecord && get(firstRecord, firstRecordName)) {\n    if(this.firstRecordKind === \"belongsTo\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        set(firstRecord, firstRecordName, null);\n      });\n     }\n     else if(this.firstRecordKind === \"hasMany\"){\n       firstRecord.suspendRelationshipObservers(function(){\n        get(firstRecord, firstRecordName).removeObject(secondRecord);\n      });\n    }\n  }\n\n  this.coalesce();\n};\n\n})();\n//@ sourceURL=ember-data/system/changes/relationship_change");minispade.register('ember-data/system/mixins/load_promise', "(function() {var Evented = Ember.Evented,              // ember-runtime/mixins/evented\n    Deferred = Ember.DeferredMixin,       // ember-runtime/mixins/evented\n    run = Ember.run,                      // ember-metal/run-loop\n    get = Ember.get;                      // ember-metal/accessors\n\nvar LoadPromise = Ember.Mixin.create(Evented, Deferred, {\n  init: function() {\n    this._super.apply(this, arguments);\n\n    this.one('didLoad', this, function() {\n      run(this, 'resolve', this);\n    });\n\n    this.one('becameError', this, function() {\n      run(this, 'reject', this);\n    });\n\n    if (get(this, 'isLoaded')) {\n      this.trigger('didLoad');\n    }\n  }\n});\n\nDS.LoadPromise = LoadPromise;\n\n})();\n//@ sourceURL=ember-data/system/mixins/load_promise");minispade.register('ember-data/system/mixins/mappable', "(function() {var get = Ember.get;\n\n/**\n  The Mappable mixin is designed for classes that would like to\n  behave as a map for configuration purposes.\n\n  For example, the DS.Adapter class can behave like a map, with\n  more semantic API, via the `map` API:\n\n    DS.Adapter.map('App.Person', { firstName: { key: 'FIRST' } });\n\n  Class configuration via a map-like API has a few common requirements\n  that differentiate it from the standard Ember.Map implementation.\n\n  First, values often are provided as strings that should be normalized\n  into classes the first time the configuration options are used.\n\n  Second, the values configured on parent classes should also be taken\n  into account.\n\n  Finally, setting the value of a key sometimes should merge with the\n  previous value, rather than replacing it.\n\n  This mixin provides a instance method, `createInstanceMapFor`, that\n  will reify all of the configuration options set on an instance's\n  constructor and provide it for the instance to use.\n\n  Classes can implement certain hooks that allow them to customize\n  the requirements listed above:\n\n  * `resolveMapConflict` - called when a value is set for an existing\n    value\n  * `transformMapKey` - allows a key name (for example, a global path\n    to a class) to be normalized\n  * `transformMapValue` - allows a value (for example, a class that\n    should be instantiated) to be normalized\n\n  Classes that implement this mixin should also implement a class\n  method built using the `generateMapFunctionFor` method:\n\n    DS.Adapter.reopenClass({\n      map: DS.Mappable.generateMapFunctionFor('attributes', function(key, newValue, map) {\n        var existingValue = map.get(key);\n\n        for (var prop in newValue) {\n          if (!newValue.hasOwnProperty(prop)) { continue; }\n          existingValue[prop] = newValue[prop];\n        }\n      })\n    });\n\n  The function passed to `generateMapFunctionFor` is invoked every time a\n  new value is added to the map.\n\n  @class _Mappable\n  @private\n  @namespace DS\n  @extends Ember.Mixin\n**/\n\nvar resolveMapConflict = function(oldValue, newValue) {\n  return oldValue;\n};\n\nvar transformMapKey = function(key, value) {\n  return key;\n};\n\nvar transformMapValue = function(key, value) {\n  return value;\n};\n\nDS._Mappable = Ember.Mixin.create({\n  createInstanceMapFor: function(mapName) {\n    var instanceMeta = getMappableMeta(this);\n\n    instanceMeta.values = instanceMeta.values || {};\n\n    if (instanceMeta.values[mapName]) { return instanceMeta.values[mapName]; }\n\n    var instanceMap = instanceMeta.values[mapName] = new Ember.Map();\n\n    var klass = this.constructor;\n\n    while (klass && klass !== DS.Store) {\n      this._copyMap(mapName, klass, instanceMap);\n      klass = klass.superclass;\n    }\n\n    instanceMeta.values[mapName] = instanceMap;\n    return instanceMap;\n  },\n\n  _copyMap: function(mapName, klass, instanceMap) {\n    var classMeta = getMappableMeta(klass);\n\n    var classMap = classMeta[mapName];\n    if (classMap) {\n      classMap.forEach(eachMap, this);\n    }\n\n    function eachMap(key, value) {\n      var transformedKey = (klass.transformMapKey || transformMapKey)(key, value);\n      var transformedValue = (klass.transformMapValue || transformMapValue)(key, value);\n\n      var oldValue = instanceMap.get(transformedKey);\n      var newValue = transformedValue;\n\n      if (oldValue) {\n        newValue = (this.constructor.resolveMapConflict || resolveMapConflict)(oldValue, newValue);\n      }\n\n      instanceMap.set(transformedKey, newValue);\n    }\n  }\n\n\n});\n\nDS._Mappable.generateMapFunctionFor = function(mapName, transform) {\n  return function(key, value) {\n    var meta = getMappableMeta(this);\n\n    var map = meta[mapName] || Ember.MapWithDefault.create({\n      defaultValue: function() { return {}; }\n    });\n\n    transform.call(this, key, value, map);\n\n    meta[mapName] = map;\n  };\n};\n\nfunction getMappableMeta(obj) {\n  var meta = Ember.meta(obj, true),\n      keyName = 'DS.Mappable',\n      value = meta[keyName];\n\n  if (!value) { meta[keyName] = {}; }\n\n  if (!meta.hasOwnProperty(keyName)) {\n    meta[keyName] = Ember.create(meta[keyName]);\n  }\n\n  return meta[keyName];\n}\n\n})();\n//@ sourceURL=ember-data/system/mixins/mappable");minispade.register('ember-data/system/model', "(function() {/**\n  @module data\n  @submodule data-model\n*/\nminispade.require(\"ember-data/system/model/model\");\nminispade.require(\"ember-data/system/model/states\");\nminispade.require(\"ember-data/system/model/attributes\");\n\n})();\n//@ sourceURL=ember-data/system/model");minispade.register('ember-data/system/model/attributes', "(function() {minispade.require(\"ember-data/system/model/model\");\n\n/**\n  @module data\n  @submodule data-model\n*/\n\nvar get = Ember.get;\n\nDS.Model.reopenClass({\n  attributes: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isAttribute) {\n        Ember.assert(\"You may not set `id` as an attribute on your model. Please remove any lines that look like: `id: DS.attr('<type>')` from \" + this.toString(), name !== 'id');\n\n        meta.name = name;\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  })\n});\n\n\nDS.Model.reopen({\n  eachAttribute: function(callback, binding) {\n    get(this.constructor, 'attributes').forEach(function(name, meta) {\n      callback.call(binding, name, meta);\n    }, binding);\n  },\n\n  attributeWillChange: Ember.beforeObserver(function(record, key) {\n    var reference = get(record, '_reference'),\n        store = get(record, 'store');\n\n    record.send('willSetProperty', { reference: reference, store: store, name: key });\n  }),\n\n  attributeDidChange: Ember.observer(function(record, key) {\n    record.send('didSetProperty', { name: key });\n  })\n});\n\nfunction getAttr(record, options, key) {\n  var attributes = get(record, 'data').attributes;\n  var value = attributes[key];\n\n  if (value === undefined) {\n    if (typeof options.defaultValue === \"function\") {\n      value = options.defaultValue();\n    } else {\n      value = options.defaultValue;\n    }\n  }\n\n  return value;\n}\n\nDS.attr = function(type, options) {\n  options = options || {};\n\n  var meta = {\n    type: type,\n    isAttribute: true,\n    options: options\n  };\n\n  return Ember.computed(function(key, value, oldValue) {\n    if (arguments.length > 1) {\n      Ember.assert(\"You may not set `id` as an attribute on your model. Please remove any lines that look like: `id: DS.attr('<type>')` from \" + this.constructor.toString(), key !== 'id');\n    } else {\n      value = getAttr(this, options, key);\n    }\n\n    return value;\n  // `data` is never set directly. However, it may be\n  // invalidated from the state manager's setData\n  // event.\n  }).property('data').meta(meta);\n};\n\n\n})();\n//@ sourceURL=ember-data/system/model/attributes");minispade.register('ember-data/system/model/model', "(function() {minispade.require(\"ember-data/system/model/states\");\nminispade.require(\"ember-data/system/mixins/load_promise\");\n\nvar LoadPromise = DS.LoadPromise; // system/mixins/load_promise\n\nvar get = Ember.get, set = Ember.set, map = Ember.EnumerableUtils.map;\n\nvar retrieveFromCurrentState = Ember.computed(function(key, value) {\n  return get(get(this, 'stateManager.currentState'), key);\n}).property('stateManager.currentState').readOnly();\n\n/**\n\n  The model class that all Ember Data records descend from.\n\n  @module data\n  @submodule data-model\n  @main data-model\n\n  @class Model\n  @namespace DS\n  @extends Ember.Object\n  @constructor\n*/\n\nDS.Model = Ember.Object.extend(Ember.Evented, LoadPromise, {\n  isLoading: retrieveFromCurrentState,\n  isLoaded: retrieveFromCurrentState,\n  isReloading: retrieveFromCurrentState,\n  isDirty: retrieveFromCurrentState,\n  isSaving: retrieveFromCurrentState,\n  isDeleted: retrieveFromCurrentState,\n  isError: retrieveFromCurrentState,\n  isNew: retrieveFromCurrentState,\n  isValid: retrieveFromCurrentState,\n  dirtyType: retrieveFromCurrentState,\n\n  clientId: null,\n  id: null,\n  transaction: null,\n  stateManager: null,\n  errors: null,\n\n  /**\n    Create a JSON representation of the record, using the serialization\n    strategy of the store's adapter.\n\n    @method serialize\n    @param {Object} options Available options:\n\n    * `includeId`: `true` if the record's ID should be included in the\n      JSON representation.\n\n    @returns {Object} an object whose values are primitive JSON values only\n  */\n  serialize: function(options) {\n    var store = get(this, 'store');\n    return store.serialize(this, options);\n  },\n\n  /**\n    Use {{#crossLink \"DS.JSONSerializer\"}}DS.JSONSerializer{{/crossLink}} to\n    get the JSON representation of a record.\n\n    @method toJSON\n    @param {Object} options Available options:\n\n    * `includeId`: `true` if the record's ID should be included in the\n      JSON representation.\n\n    @returns {Object} A JSON representation of the object.\n  */\n  toJSON: function(options) {\n    var serializer = DS.JSONSerializer.create();\n    return serializer.serialize(this, options);\n  },\n\n  /**\n    Fired when the record is loaded from the server.\n\n    @event didLoad\n  */\n  didLoad: Ember.K,\n\n  /**\n    Fired when the record is reloaded from the server.\n\n    @event didReload\n  */\n  didReload: Ember.K,\n\n  /**\n    Fired when the record is updated.\n\n    @event didUpdate\n  */\n  didUpdate: Ember.K,\n\n  /**\n    Fired when the record is created.\n\n    @event didCreate\n  */\n  didCreate: Ember.K,\n\n  /**\n    Fired when the record is deleted.\n\n    @event didDelete\n  */\n  didDelete: Ember.K,\n\n  /**\n    Fired when the record becomes invalid.\n\n    @event becameInvalid\n  */\n  becameInvalid: Ember.K,\n\n  /**\n    Fired when the record enters the error state.\n\n    @event becameError\n  */\n  becameError: Ember.K,\n\n  data: Ember.computed(function() {\n    if (!this._data) {\n      this.setupData();\n    }\n\n    return this._data;\n  }).property(),\n\n  materializeData: function() {\n    this.send('materializingData');\n\n    get(this, 'store').materializeData(this);\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  },\n\n  _data: null,\n\n  init: function() {\n    this._super();\n\n    var stateManager = DS.StateManager.create({ record: this });\n    set(this, 'stateManager', stateManager);\n\n    this._setup();\n\n    stateManager.goToState('empty');\n  },\n\n  _setup: function() {\n    this._changesToSync = {};\n  },\n\n  send: function(name, context) {\n    return get(this, 'stateManager').send(name, context);\n  },\n\n  withTransaction: function(fn) {\n    var transaction = get(this, 'transaction');\n    if (transaction) { fn(transaction); }\n  },\n\n  loadingData: function() {\n    this.send('loadingData');\n  },\n\n  loadedData: function() {\n    this.send('loadedData');\n  },\n\n  didChangeData: function() {\n    this.send('didChangeData');\n  },\n\n  deleteRecord: function() {\n    this.send('deleteRecord');\n  },\n\n  unloadRecord: function() {\n    Ember.assert(\"You can only unload a loaded, non-dirty record.\", !get(this, 'isDirty'));\n\n    this.send('unloadRecord');\n  },\n\n  clearRelationships: function() {\n    this.eachRelationship(function(name, relationship) {\n      if (relationship.kind === 'belongsTo') {\n        set(this, name, null);\n      } else if (relationship.kind === 'hasMany') {\n        this.clearHasMany(relationship);\n      }\n    }, this);\n  },\n\n  updateRecordArrays: function() {\n    var store = get(this, 'store');\n    if (store) {\n      store.dataWasUpdated(this.constructor, get(this, '_reference'), this);\n    }\n  },\n\n  /**\n    If the adapter did not return a hash in response to a commit,\n    merge the changed attributes and relationships into the existing\n    saved data.\n  */\n  adapterDidCommit: function() {\n    var attributes = get(this, 'data').attributes;\n\n    get(this.constructor, 'attributes').forEach(function(name, meta) {\n      attributes[name] = get(this, name);\n    }, this);\n\n    this.send('didCommit');\n    this.updateRecordArraysLater();\n  },\n\n  adapterDidDirty: function() {\n    this.send('becomeDirty');\n    this.updateRecordArraysLater();\n  },\n\n  dataDidChange: Ember.observer(function() {\n    this.reloadHasManys();\n    this.send('finishedMaterializing');\n  }, 'data'),\n\n  reloadHasManys: function() {\n    var relationships = get(this.constructor, 'relationshipsByName');\n    this.updateRecordArraysLater();\n    relationships.forEach(function(name, relationship) {\n      if (relationship.kind === 'hasMany') {\n        this.hasManyDidChange(relationship.key);\n      }\n    }, this);\n  },\n\n  hasManyDidChange: function(key) {\n    var cachedValue = this.cacheFor(key);\n\n    if (cachedValue) {\n      var type = get(this.constructor, 'relationshipsByName').get(key).type;\n      var store = get(this, 'store');\n      var ids = this._data.hasMany[key] || [];\n\n      var references = map(ids, function(id) {\n        if (typeof id === 'object') {\n          if( id.clientId ) {\n            // if it was already a reference, return the reference\n            return id;\n          } else {\n            // <id, type> tuple for a polymorphic association.\n            return store.referenceForId(id.type, id.id);\n          }\n        }\n        return store.referenceForId(type, id);\n      });\n\n      set(cachedValue, 'content', Ember.A(references));\n    }\n  },\n\n  updateRecordArraysLater: function() {\n    Ember.run.once(this, this.updateRecordArrays);\n  },\n\n  setupData: function() {\n    this._data = {\n      attributes: {},\n      belongsTo: {},\n      hasMany: {},\n      id: null\n    };\n  },\n\n  materializeId: function(id) {\n    set(this, 'id', id);\n  },\n\n  materializeAttributes: function(attributes) {\n    Ember.assert(\"Must pass a hash of attributes to materializeAttributes\", !!attributes);\n    this._data.attributes = attributes;\n  },\n\n  materializeAttribute: function(name, value) {\n    this._data.attributes[name] = value;\n  },\n\n  materializeHasMany: function(name, tuplesOrReferencesOrOpaque) {\n    var tuplesOrReferencesOrOpaqueType = typeof tuplesOrReferencesOrOpaque;\n    if (tuplesOrReferencesOrOpaque && tuplesOrReferencesOrOpaqueType !== 'string' && tuplesOrReferencesOrOpaque.length > 1) { Ember.assert('materializeHasMany expects tuples, references or opaque token, not ' + tuplesOrReferencesOrOpaque[0], tuplesOrReferencesOrOpaque[0].hasOwnProperty('id') && tuplesOrReferencesOrOpaque[0].type); }\n    if( tuplesOrReferencesOrOpaqueType === \"string\" ) {\n      this._data.hasMany[name] = tuplesOrReferencesOrOpaque;\n    } else {\n      var references = tuplesOrReferencesOrOpaque;\n\n      if (tuplesOrReferencesOrOpaque && Ember.isArray(tuplesOrReferencesOrOpaque)) {\n        references = this._convertTuplesToReferences(tuplesOrReferencesOrOpaque);\n      }\n\n      this._data.hasMany[name] = references;\n    }\n  },\n\n  materializeBelongsTo: function(name, tupleOrReference) {\n    if (tupleOrReference) { Ember.assert('materializeBelongsTo expects a tuple or a reference, not a ' + tupleOrReference, !tupleOrReference || (tupleOrReference.hasOwnProperty('id') && tupleOrReference.hasOwnProperty('type'))); }\n\n    this._data.belongsTo[name] = tupleOrReference;\n  },\n\n  _convertTuplesToReferences: function(tuplesOrReferences) {\n    return map(tuplesOrReferences, function(tupleOrReference) {\n      return this._convertTupleToReference(tupleOrReference);\n    }, this);\n  },\n\n  _convertTupleToReference: function(tupleOrReference) {\n    var store = get(this, 'store');\n    if(tupleOrReference.clientId) {\n      return tupleOrReference;\n    } else {\n      return store.referenceForId(tupleOrReference.type, tupleOrReference.id);\n    }\n  },\n\n  rollback: function() {\n    this._setup();\n    this.send('becameClean');\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  },\n\n  toStringExtension: function() {\n    return get(this, 'id');\n  },\n\n  /**\n    @private\n\n    The goal of this method is to temporarily disable specific observers\n    that take action in response to application changes.\n\n    This allows the system to make changes (such as materialization and\n    rollback) that should not trigger secondary behavior (such as setting an\n    inverse relationship or marking records as dirty).\n\n    The specific implementation will likely change as Ember proper provides\n    better infrastructure for suspending groups of observers, and if Array\n    observation becomes more unified with regular observers.\n  */\n  suspendRelationshipObservers: function(callback, binding) {\n    var observers = get(this.constructor, 'relationshipNames').belongsTo;\n    var self = this;\n\n    try {\n      this._suspendedRelationships = true;\n      Ember._suspendObservers(self, observers, null, 'belongsToDidChange', function() {\n        Ember._suspendBeforeObservers(self, observers, null, 'belongsToWillChange', function() {\n          callback.call(binding || self);\n        });\n      });\n    } finally {\n      this._suspendedRelationships = false;\n    }\n  },\n\n  becameInFlight: function() {\n  },\n\n  /**\n    @private\n\n  */\n  resolveOn: function(successEvent) {\n    var model = this;\n\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n      function success() {\n        this.off('becameError', error);\n        this.off('becameInvalid', error);\n        resolve(this);\n      }\n      function error() {\n        this.off(successEvent, success);\n        reject(this);\n      }\n\n      model.one(successEvent, success);\n      model.one('becameError', error);\n      model.one('becameInvalid', error);\n    });\n  },\n\n  /**\n    Save the record.\n\n    @method save\n  */\n  save: function() {\n    this.get('store').scheduleSave(this);\n\n    return this.resolveOn('didCommit');\n  },\n\n  /**\n    Reload the record from the adapter.\n\n    This will only work if the record has already finished loading\n    and has not yet been modified (`isLoaded` but not `isDirty`,\n    or `isSaving`).\n\n    @method reload\n  */\n  reload: function() {\n    this.send('reloadRecord');\n\n    return this.resolveOn('didReload');\n  },\n\n  // FOR USE DURING COMMIT PROCESS\n\n  adapterDidUpdateAttribute: function(attributeName, value) {\n\n    // If a value is passed in, update the internal attributes and clear\n    // the attribute cache so it picks up the new value. Otherwise,\n    // collapse the current value into the internal attributes because\n    // the adapter has acknowledged it.\n    if (value !== undefined) {\n      get(this, 'data.attributes')[attributeName] = value;\n      this.notifyPropertyChange(attributeName);\n    } else {\n      value = get(this, attributeName);\n      get(this, 'data.attributes')[attributeName] = value;\n    }\n\n    this.updateRecordArraysLater();\n  },\n\n  adapterDidInvalidate: function(errors) {\n    this.send('becameInvalid', errors);\n  },\n\n  adapterDidError: function() {\n    this.send('becameError');\n  },\n\n  /**\n    @private\n\n    Override the default event firing from Ember.Evented to\n    also call methods with the given name.\n  */\n  trigger: function(name) {\n    Ember.tryInvoke(this, name, [].slice.call(arguments, 1));\n    this._super.apply(this, arguments);\n  }\n});\n\n// Helper function to generate store aliases.\n// This returns a function that invokes the named alias\n// on the default store, but injects the class as the\n// first parameter.\nvar storeAlias = function(methodName) {\n  return function() {\n    var store = get(DS, 'defaultStore'),\n        args = [].slice.call(arguments);\n\n    args.unshift(this);\n    Ember.assert(\"Your application does not have a 'Store' property defined. Attempts to call '\" + methodName + \"' on model classes will fail. Please provide one as with 'YourAppName.Store = DS.Store.extend()'\", !!store);\n    return store[methodName].apply(store, args);\n  };\n};\n\nDS.Model.reopenClass({\n\n  /** @private\n    Alias DS.Model's `create` method to `_create`. This allows us to create DS.Model\n    instances from within the store, but if end users accidentally call `create()`\n    (instead of `createRecord()`), we can raise an error.\n  */\n  _create: DS.Model.create,\n\n  /** @private\n\n    Override the class' `create()` method to raise an error. This prevents end users\n    from inadvertently calling `create()` instead of `createRecord()`. The store is\n    still able to create instances by calling the `_create()` method.\n  */\n  create: function() {\n    throw new Ember.Error(\"You should not call `create` on a model. Instead, call `createRecord` with the attributes you would like to set.\");\n  },\n\n  /**\n    See {{#crossLink \"DS.Store/find:method\"}}`DS.Store.find()`{{/crossLink}}.\n\n    @method find\n    @param {Object|String|Array|null} query A query to find records by.\n\n  */\n  find: storeAlias('find'),\n\n  /**\n    See {{#crossLink \"DS.Store/all:method\"}}`DS.Store.all()`{{/crossLink}}.\n\n    @method all\n    @return {DS.RecordArray}\n  */\n  all: storeAlias('all'),\n\n  /**\n    See {{#crossLink \"DS.Store/findQuery:method\"}}`DS.Store.findQuery()`{{/crossLink}}.\n\n    @method query\n    @param {Object} query an opaque query to be used by the adapter\n    @return {DS.AdapterPopulatedRecordArray}\n  */\n  query: storeAlias('findQuery'),\n\n  /**\n    See {{#crossLink \"DS.Store/filter:method\"}}`DS.Store.filter()`{{/crossLink}}.\n\n    @method filter\n    @param {Function} filter\n    @return {DS.FilteredRecordArray}\n  */\n  filter: storeAlias('filter'),\n\n  /**\n    See {{#crossLink \"DS.Store/createRecord:method\"}}`DS.Store.createRecord()`{{/crossLink}}.\n\n    @method createRecord\n    @param {Object} properties a hash of properties to set on the\n      newly created record.\n    @returns DS.Model\n  */\n  createRecord: storeAlias('createRecord')\n});\n\n})();\n//@ sourceURL=ember-data/system/model/model");minispade.register('ember-data/system/model/states', "(function() {/**\n  @module data\n  @submodule data-model\n*/\n\nvar get = Ember.get, set = Ember.set,\n    once = Ember.run.once, arrayMap = Ember.ArrayPolyfills.map;\n\n/**\n  This file encapsulates the various states that a record can transition\n  through during its lifecycle.\n\n  ### State Manager\n\n  A record's state manager explicitly tracks what state a record is in\n  at any given time. For instance, if a record is newly created and has\n  not yet been sent to the adapter to be saved, it would be in the\n  `created.uncommitted` state.  If a record has had local modifications\n  made to it that are in the process of being saved, the record would be\n  in the `updated.inFlight` state. (These state paths will be explained\n  in more detail below.)\n\n  Events are sent by the record or its store to the record's state manager.\n  How the state manager reacts to these events is dependent on which state\n  it is in. In some states, certain events will be invalid and will cause\n  an exception to be raised.\n\n  States are hierarchical. For example, a record can be in the\n  `deleted.start` state, then transition into the `deleted.inFlight` state.\n  If a child state does not implement an event handler, the state manager\n  will attempt to invoke the event on all parent states until the root state is\n  reached. The state hierarchy of a record is described in terms of a path\n  string. You can determine a record's current state by getting its manager's\n  current state path:\n\n      record.get('stateManager.currentPath');\n      //=> \"created.uncommitted\"\n\n  The `DS.Model` states are themselves stateless. What we mean is that,\n  though each instance of a record also has a unique instance of a\n  `DS.StateManager`, the hierarchical states that each of *those* points\n  to is a shared data structure. For performance reasons, instead of each\n  record getting its own copy of the hierarchy of states, each state\n  manager points to this global, immutable shared instance. How does a\n  state know which record it should be acting on?  We pass a reference to\n  the current state manager as the first parameter to every method invoked\n  on a state.\n\n  The state manager passed as the first parameter is where you should stash\n  state about the record if needed; you should never store data on the state\n  object itself. If you need access to the record being acted on, you can\n  retrieve the state manager's `record` property. For example, if you had\n  an event handler `myEvent`:\n\n      myEvent: function(manager) {\n        var record = manager.get('record');\n        record.doSomething();\n      }\n\n  For more information about state managers in general, see the Ember.js\n  documentation on `Ember.StateManager`.\n\n  ### Events, Flags, and Transitions\n\n  A state may implement zero or more events, flags, or transitions.\n\n  #### Events\n\n  Events are named functions that are invoked when sent to a record. The\n  state manager will first look for a method with the given name on the\n  current state. If no method is found, it will search the current state's\n  parent, and then its grandparent, and so on until reaching the top of\n  the hierarchy. If the root is reached without an event handler being found,\n  an exception will be raised. This can be very helpful when debugging new\n  features.\n\n  Here's an example implementation of a state with a `myEvent` event handler:\n\n      aState: DS.State.create({\n        myEvent: function(manager, param) {\n          console.log(\"Received myEvent with \"+param);\n        }\n      })\n\n  To trigger this event:\n\n      record.send('myEvent', 'foo');\n      //=> \"Received myEvent with foo\"\n\n  Note that an optional parameter can be sent to a record's `send()` method,\n  which will be passed as the second parameter to the event handler.\n\n  Events should transition to a different state if appropriate. This can be\n  done by calling the state manager's `transitionTo()` method with a path to the\n  desired state. The state manager will attempt to resolve the state path\n  relative to the current state. If no state is found at that path, it will\n  attempt to resolve it relative to the current state's parent, and then its\n  parent, and so on until the root is reached. For example, imagine a hierarchy\n  like this:\n\n      * created\n        * start <-- currentState\n        * inFlight\n      * updated\n        * inFlight\n\n  If we are currently in the `start` state, calling\n  `transitionTo('inFlight')` would transition to the `created.inFlight` state,\n  while calling `transitionTo('updated.inFlight')` would transition to\n  the `updated.inFlight` state.\n\n  Remember that *only events* should ever cause a state transition. You should\n  never call `transitionTo()` from outside a state's event handler. If you are\n  tempted to do so, create a new event and send that to the state manager.\n\n  #### Flags\n\n  Flags are Boolean values that can be used to introspect a record's current\n  state in a more user-friendly way than examining its state path. For example,\n  instead of doing this:\n\n      var statePath = record.get('stateManager.currentPath');\n      if (statePath === 'created.inFlight') {\n        doSomething();\n      }\n\n  You can say:\n\n      if (record.get('isNew') && record.get('isSaving')) {\n        doSomething();\n      }\n\n  If your state does not set a value for a given flag, the value will\n  be inherited from its parent (or the first place in the state hierarchy\n  where it is defined).\n\n  The current set of flags are defined below. If you want to add a new flag,\n  in addition to the area below, you will also need to declare it in the\n  `DS.Model` class.\n\n  #### Transitions\n\n  Transitions are like event handlers but are called automatically upon\n  entering or exiting a state. To implement a transition, just call a method\n  either `enter` or `exit`:\n\n      myState: DS.State.create({\n        // Gets called automatically when entering\n        // this state.\n        enter: function(manager) {\n          console.log(\"Entered myState\");\n        }\n      })\n\n  Note that enter and exit events are called once per transition. If the\n  current state changes, but changes to another child state of the parent,\n  the transition event on the parent will not be triggered.\n\n  @class States\n  @namespace DS\n  @extends Ember.State\n*/\n\nvar stateProperty = Ember.computed(function(key) {\n  var parent = get(this, 'parentState');\n  if (parent) {\n    return get(parent, key);\n  }\n}).property();\n\nvar hasDefinedProperties = function(object) {\n  for (var name in object) {\n    if (object.hasOwnProperty(name) && object[name]) { return true; }\n  }\n\n  return false;\n};\n\nvar didChangeData = function(manager) {\n  var record = get(manager, 'record');\n  record.materializeData();\n};\n\nvar willSetProperty = function(manager, context) {\n  context.oldValue = get(get(manager, 'record'), context.name);\n\n  var change = DS.AttributeChange.createChange(context);\n  get(manager, 'record')._changesToSync[context.name] = change;\n};\n\nvar didSetProperty = function(manager, context) {\n  var change = get(manager, 'record')._changesToSync[context.name];\n  change.value = get(get(manager, 'record'), context.name);\n  change.sync();\n};\n\nDS.State = Ember.State.extend({\n  isLoading: stateProperty,\n  isLoaded: stateProperty,\n  isReloading: stateProperty,\n  isDirty: stateProperty,\n  isSaving: stateProperty,\n  isDeleted: stateProperty,\n  isError: stateProperty,\n  isNew: stateProperty,\n  isValid: stateProperty,\n\n  // For states that are substates of a\n  // DirtyState (updated or created), it is\n  // useful to be able to determine which\n  // type of dirty state it is.\n  dirtyType: stateProperty\n});\n\n// Implementation notes:\n//\n// Each state has a boolean value for all of the following flags:\n//\n// * isLoaded: The record has a populated `data` property. When a\n//   record is loaded via `store.find`, `isLoaded` is false\n//   until the adapter sets it. When a record is created locally,\n//   its `isLoaded` property is always true.\n// * isDirty: The record has local changes that have not yet been\n//   saved by the adapter. This includes records that have been\n//   created (but not yet saved) or deleted.\n// * isSaving: The record's transaction has been committed, but\n//   the adapter has not yet acknowledged that the changes have\n//   been persisted to the backend.\n// * isDeleted: The record was marked for deletion. When `isDeleted`\n//   is true and `isDirty` is true, the record is deleted locally\n//   but the deletion was not yet persisted. When `isSaving` is\n//   true, the change is in-flight. When both `isDirty` and\n//   `isSaving` are false, the change has persisted.\n// * isError: The adapter reported that it was unable to save\n//   local changes to the backend. This may also result in the\n//   record having its `isValid` property become false if the\n//   adapter reported that server-side validations failed.\n// * isNew: The record was created on the client and the adapter\n//   did not yet report that it was successfully saved.\n// * isValid: No client-side validations have failed and the\n//   adapter did not report any server-side validation failures.\n\n// The dirty state is a abstract state whose functionality is\n// shared between the `created` and `updated` states.\n//\n// The deleted state shares the `isDirty` flag with the\n// subclasses of `DirtyState`, but with a very different\n// implementation.\n//\n// Dirty states have three child states:\n//\n// `uncommitted`: the store has not yet handed off the record\n//   to be saved.\n// `inFlight`: the store has handed off the record to be saved,\n//   but the adapter has not yet acknowledged success.\n// `invalid`: the record has invalid information and cannot be\n//   send to the adapter yet.\nvar DirtyState = DS.State.extend({\n  initialState: 'uncommitted',\n\n  // FLAGS\n  isDirty: true,\n\n  // SUBSTATES\n\n  // When a record first becomes dirty, it is `uncommitted`.\n  // This means that there are local pending changes, but they\n  // have not yet begun to be saved, and are not invalid.\n  uncommitted: DS.State.extend({\n\n    // EVENTS\n    willSetProperty: willSetProperty,\n    didSetProperty: didSetProperty,\n\n    becomeDirty: Ember.K,\n\n    willCommit: function(manager) {\n      manager.transitionTo('inFlight');\n    },\n\n    becameClean: function(manager) {\n      var record = get(manager, 'record');\n\n      record.withTransaction(function(t) {\n        t.remove(record);\n      });\n      manager.transitionTo('loaded.materializing');\n    },\n\n    becameInvalid: function(manager) {\n      manager.transitionTo('invalid');\n    },\n\n    rollback: function(manager) {\n      get(manager, 'record').rollback();\n    }\n  }),\n\n  // Once a record has been handed off to the adapter to be\n  // saved, it is in the 'in flight' state. Changes to the\n  // record cannot be made during this window.\n  inFlight: DS.State.extend({\n    // FLAGS\n    isSaving: true,\n\n    // TRANSITIONS\n    enter: function(manager) {\n      var record = get(manager, 'record');\n\n      record.becameInFlight();\n    },\n\n    // EVENTS\n\n    materializingData: function(manager) {\n      set(manager, 'lastDirtyType', get(this, 'dirtyType'));\n      manager.transitionTo('materializing');\n    },\n\n    didCommit: function(manager) {\n      var dirtyType = get(this, 'dirtyType'),\n          record = get(manager, 'record');\n\n      record.withTransaction(function(t) {\n        t.remove(record);\n      });\n\n      manager.transitionTo('saved');\n      manager.send('invokeLifecycleCallbacks', dirtyType);\n    },\n\n    didChangeData: didChangeData,\n\n    becameInvalid: function(manager, errors) {\n      var record = get(manager, 'record');\n\n      set(record, 'errors', errors);\n\n      manager.transitionTo('invalid');\n      manager.send('invokeLifecycleCallbacks');\n    },\n\n    becameError: function(manager) {\n      manager.transitionTo('error');\n      manager.send('invokeLifecycleCallbacks');\n    }\n  }),\n\n  // A record is in the `invalid` state when its client-side\n  // invalidations have failed, or if the adapter has indicated\n  // the the record failed server-side invalidations.\n  invalid: DS.State.extend({\n    // FLAGS\n    isValid: false,\n\n    exit: function(manager) {\n       var record = get(manager, 'record');\n\n       record.withTransaction(function (t) {\n         t.remove(record);\n       });\n     },\n\n    // EVENTS\n    deleteRecord: function(manager) {\n      manager.transitionTo('deleted');\n      get(manager, 'record').clearRelationships();\n    },\n\n    willSetProperty: willSetProperty,\n\n    didSetProperty: function(manager, context) {\n      var record = get(manager, 'record'),\n          errors = get(record, 'errors'),\n          key = context.name;\n\n      set(errors, key, null);\n\n      if (!hasDefinedProperties(errors)) {\n        manager.send('becameValid');\n      }\n\n      didSetProperty(manager, context);\n    },\n\n    becomeDirty: Ember.K,\n\n    rollback: function(manager) {\n      manager.send('becameValid');\n      manager.send('rollback');\n    },\n\n    becameValid: function(manager) {\n      manager.transitionTo('uncommitted');\n    },\n\n    invokeLifecycleCallbacks: function(manager) {\n      var record = get(manager, 'record');\n      record.trigger('becameInvalid', record);\n    }\n  })\n});\n\n// The created and updated states are created outside the state\n// chart so we can reopen their substates and add mixins as\n// necessary.\n\nvar createdState = DirtyState.create({\n  dirtyType: 'created',\n\n  // FLAGS\n  isNew: true\n});\n\nvar updatedState = DirtyState.create({\n  dirtyType: 'updated'\n});\n\ncreatedState.states.uncommitted.reopen({\n  deleteRecord: function(manager) {\n    var record = get(manager, 'record');\n\n    record.clearRelationships();\n    manager.transitionTo('deleted.saved');\n  }\n});\n\ncreatedState.states.uncommitted.reopen({\n  rollback: function(manager) {\n    this._super(manager);\n    manager.transitionTo('deleted.saved');\n  }\n});\n\nupdatedState.states.uncommitted.reopen({\n  deleteRecord: function(manager) {\n    var record = get(manager, 'record');\n\n    manager.transitionTo('deleted');\n    record.clearRelationships();\n  }\n});\n\nvar states = {\n  rootState: Ember.State.create({\n    // FLAGS\n    isLoading: false,\n    isLoaded: false,\n    isReloading: false,\n    isDirty: false,\n    isSaving: false,\n    isDeleted: false,\n    isError: false,\n    isNew: false,\n    isValid: true,\n\n    // SUBSTATES\n\n    // A record begins its lifecycle in the `empty` state.\n    // If its data will come from the adapter, it will\n    // transition into the `loading` state. Otherwise, if\n    // the record is being created on the client, it will\n    // transition into the `created` state.\n    empty: DS.State.create({\n      // EVENTS\n      loadingData: function(manager) {\n        manager.transitionTo('loading');\n      },\n\n      loadedData: function(manager) {\n        manager.transitionTo('loaded.created');\n      }\n    }),\n\n    // A record enters this state when the store askes\n    // the adapter for its data. It remains in this state\n    // until the adapter provides the requested data.\n    //\n    // Usually, this process is asynchronous, using an\n    // XHR to retrieve the data.\n    loading: DS.State.create({\n      // FLAGS\n      isLoading: true,\n\n      // EVENTS\n      loadedData: didChangeData,\n\n      materializingData: function(manager) {\n        manager.transitionTo('loaded.materializing.firstTime');\n      },\n\n      becameError: function(manager) {\n        manager.transitionTo('error');\n        manager.send('invokeLifecycleCallbacks');\n      }\n    }),\n\n    // A record enters this state when its data is populated.\n    // Most of a record's lifecycle is spent inside substates\n    // of the `loaded` state.\n    loaded: DS.State.create({\n      initialState: 'saved',\n\n      // FLAGS\n      isLoaded: true,\n\n      // SUBSTATES\n\n      materializing: DS.State.create({\n        // EVENTS\n        willSetProperty: Ember.K,\n        didSetProperty: Ember.K,\n\n        didChangeData: didChangeData,\n\n        finishedMaterializing: function(manager) {\n          manager.transitionTo('loaded.saved');\n        },\n\n        // SUBSTATES\n        firstTime: DS.State.create({\n          // FLAGS\n          isLoaded: false,\n\n          exit: function(manager) {\n            var record = get(manager, 'record');\n\n            once(function() {\n              record.trigger('didLoad');\n            });\n          }\n        })\n      }),\n\n      reloading: DS.State.create({\n        // FLAGS\n        isReloading: true,\n\n        // TRANSITIONS\n        enter: function(manager) {\n          var record = get(manager, 'record'),\n              store = get(record, 'store');\n\n          store.reloadRecord(record);\n        },\n\n        exit: function(manager) {\n          var record = get(manager, 'record');\n\n          once(record, 'trigger', 'didReload');\n        },\n\n        // EVENTS\n        loadedData: didChangeData,\n\n        materializingData: function(manager) {\n          manager.transitionTo('loaded.materializing');\n        }\n      }),\n\n      // If there are no local changes to a record, it remains\n      // in the `saved` state.\n      saved: DS.State.create({\n        // EVENTS\n        willSetProperty: willSetProperty,\n        didSetProperty: didSetProperty,\n\n        didChangeData: didChangeData,\n        loadedData: didChangeData,\n\n        reloadRecord: function(manager) {\n          manager.transitionTo('loaded.reloading');\n        },\n\n        materializingData: function(manager) {\n          manager.transitionTo('loaded.materializing');\n        },\n\n        becomeDirty: function(manager) {\n          manager.transitionTo('updated');\n        },\n\n        deleteRecord: function(manager) {\n          manager.transitionTo('deleted');\n          get(manager, 'record').clearRelationships();\n        },\n\n        unloadRecord: function(manager) {\n          var record = get(manager, 'record');\n\n          // clear relationships before moving to deleted state\n          // otherwise it fails\n          record.clearRelationships();\n          manager.transitionTo('deleted.saved');\n        },\n\n        didCommit: function(manager) {\n          var record = get(manager, 'record');\n\n          record.withTransaction(function(t) {\n            t.remove(record);\n          });\n\n          manager.send('invokeLifecycleCallbacks', get(manager, 'lastDirtyType'));\n        },\n\n        invokeLifecycleCallbacks: function(manager, dirtyType) {\n          var record = get(manager, 'record');\n          if (dirtyType === 'created') {\n            record.trigger('didCreate', record);\n          } else {\n            record.trigger('didUpdate', record);\n          }\n\n          record.trigger('didCommit', record);\n        }\n      }),\n\n      // A record is in this state after it has been locally\n      // created but before the adapter has indicated that\n      // it has been saved.\n      created: createdState,\n\n      // A record is in this state if it has already been\n      // saved to the server, but there are new local changes\n      // that have not yet been saved.\n      updated: updatedState\n    }),\n\n    // A record is in this state if it was deleted from the store.\n    deleted: DS.State.create({\n      initialState: 'uncommitted',\n      dirtyType: 'deleted',\n\n      // FLAGS\n      isDeleted: true,\n      isLoaded: true,\n      isDirty: true,\n\n      // TRANSITIONS\n      setup: function(manager) {\n        var record = get(manager, 'record'),\n            store = get(record, 'store');\n\n        store.recordArrayManager.remove(record);\n      },\n\n      // SUBSTATES\n\n      // When a record is deleted, it enters the `start`\n      // state. It will exit this state when the record's\n      // transaction starts to commit.\n      uncommitted: DS.State.create({\n\n        // EVENTS\n        willCommit: function(manager) {\n          manager.transitionTo('inFlight');\n        },\n\n        rollback: function(manager) {\n          get(manager, 'record').rollback();\n        },\n\n        becomeDirty: Ember.K,\n\n        becameClean: function(manager) {\n          var record = get(manager, 'record');\n\n          record.withTransaction(function(t) {\n            t.remove(record);\n          });\n          manager.transitionTo('loaded.materializing');\n        }\n      }),\n\n      // After a record's transaction is committing, but\n      // before the adapter indicates that the deletion\n      // has saved to the server, a record is in the\n      // `inFlight` substate of `deleted`.\n      inFlight: DS.State.create({\n        // FLAGS\n        isSaving: true,\n\n        // TRANSITIONS\n        enter: function(manager) {\n          var record = get(manager, 'record');\n\n          record.becameInFlight();\n        },\n\n        // EVENTS\n        didCommit: function(manager) {\n          var record = get(manager, 'record');\n\n          record.withTransaction(function(t) {\n            t.remove(record);\n          });\n\n          manager.transitionTo('saved');\n\n          manager.send('invokeLifecycleCallbacks');\n        }\n      }),\n\n      // Once the adapter indicates that the deletion has\n      // been saved, the record enters the `saved` substate\n      // of `deleted`.\n      saved: DS.State.create({\n        // FLAGS\n        isDirty: false,\n\n        setup: function(manager) {\n          var record = get(manager, 'record'),\n              store = get(record, 'store');\n\n          store.dematerializeRecord(record);\n        },\n\n        invokeLifecycleCallbacks: function(manager) {\n          var record = get(manager, 'record');\n          record.trigger('didDelete', record);\n          record.trigger('didCommit', record);\n        }\n      })\n    }),\n\n    // If the adapter indicates that there was an unknown\n    // error saving a record, the record enters the `error`\n    // state.\n    error: DS.State.create({\n      isError: true,\n\n      // EVENTS\n\n      invokeLifecycleCallbacks: function(manager) {\n        var record = get(manager, 'record');\n        record.trigger('becameError', record);\n      }\n    })\n  })\n};\n\nDS.StateManager = Ember.StateManager.extend({\n  record: null,\n  initialState: 'rootState',\n  states: states,\n  unhandledEvent: function(manager, originalEvent) {\n    var record = manager.get('record'),\n        contexts = [].slice.call(arguments, 2),\n        errorMessage;\n    errorMessage  = \"Attempted to handle event `\" + originalEvent + \"` \";\n    errorMessage += \"on \" + record.toString() + \" while in state \";\n    errorMessage += get(manager, 'currentState.path') + \". Called with \";\n    errorMessage += arrayMap.call(contexts, function(context){\n                      return Ember.inspect(context);\n                    }).join(', ');\n    throw new Ember.Error(errorMessage);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/model/states");minispade.register('ember-data/system/record_array_manager', "(function() {var get = Ember.get, set = Ember.set;\nvar once = Ember.run.once;\nvar forEach = Ember.EnumerableUtils.forEach;\n\nDS.RecordArrayManager = Ember.Object.extend({\n  init: function() {\n    this.filteredRecordArrays = Ember.MapWithDefault.create({\n      defaultValue: function() { return []; }\n    });\n\n    this.changedReferences = [];\n  },\n\n  referenceDidChange: function(reference) {\n    this.changedReferences.push(reference);\n    once(this, this.updateRecordArrays);\n  },\n\n  recordArraysForReference: function(reference) {\n    reference.recordArrays = reference.recordArrays || Ember.OrderedSet.create();\n    return reference.recordArrays;\n  },\n\n  /**\n    @private\n\n    This method is invoked whenever data is loaded into the store\n    by the adapter or updated by the adapter, or when an attribute\n    changes on a record.\n\n    It updates all filters that a record belongs to.\n\n    To avoid thrashing, it only runs once per run loop per record.\n\n    @param {Class} type\n    @param {Number|String} clientId\n  */\n  updateRecordArrays: function() {\n    forEach(this.changedReferences, function(reference) {\n      var type = reference.type,\n          recordArrays = this.filteredRecordArrays.get(type),\n          filter;\n\n      forEach(recordArrays, function(array) {\n        filter = get(array, 'filterFunction');\n        this.updateRecordArray(array, filter, type, reference);\n      }, this);\n\n      // loop through all manyArrays containing an unloaded copy of this\n      // clientId and notify them that the record was loaded.\n      var manyArrays = reference.loadingRecordArrays;\n\n      if (manyArrays) {\n        for (var i=0, l=manyArrays.length; i<l; i++) {\n          manyArrays[i].loadedRecord();\n        }\n\n        reference.loadingRecordArrays = [];\n      }\n    }, this);\n\n    this.changedReferences = [];\n  },\n\n  /**\n    @private\n\n    Update an individual filter.\n\n    @param {DS.FilteredRecordArray} array\n    @param {Function} filter\n    @param {Class} type\n    @param {Number|String} clientId\n  */\n  updateRecordArray: function(array, filter, type, reference) {\n    var shouldBeInArray, record;\n\n    if (!filter) {\n      shouldBeInArray = true;\n    } else {\n      record = this.store.recordForReference(reference);\n      shouldBeInArray = filter(record);\n    }\n\n    var recordArrays = this.recordArraysForReference(reference);\n\n    if (shouldBeInArray) {\n      recordArrays.add(array);\n      array.addReference(reference);\n    } else if (!shouldBeInArray) {\n      recordArrays.remove(array);\n      array.removeReference(reference);\n    }\n  },\n\n  /**\n    @private\n\n    When a record is deleted, it is removed from all its\n    record arrays.\n\n    @param {DS.Model} record\n  */\n  remove: function(record) {\n    var reference = get(record, '_reference');\n    var recordArrays = reference.recordArrays || [];\n\n    recordArrays.forEach(function(array) {\n      array.removeReference(reference);\n    });\n  },\n\n  /**\n    @private\n\n    This method is invoked if the `filterFunction` property is\n    changed on a `DS.FilteredRecordArray`.\n\n    It essentially re-runs the filter from scratch. This same\n    method is invoked when the filter is created in th first place.\n  */\n  updateFilter: function(array, type, filter) {\n    var typeMap = this.store.typeMapFor(type),\n        references = typeMap.references,\n        reference, data, shouldFilter, record;\n\n    for (var i=0, l=references.length; i<l; i++) {\n      reference = references[i];\n      shouldFilter = false;\n\n      data = reference.data;\n\n      if (typeof data === 'object') {\n        if (record = reference.record) {\n          if (!get(record, 'isDeleted')) { shouldFilter = true; }\n        } else {\n          shouldFilter = true;\n        }\n\n        if (shouldFilter) {\n          this.updateRecordArray(array, filter, type, reference);\n        }\n      }\n    }\n  },\n\n  /**\n    @private\n\n    Create a `DS.ManyArray` for a type and list of record references, and index\n    the `ManyArray` under each reference. This allows us to efficiently remove\n    records from `ManyArray`s when they are deleted.\n\n    @param {Class} type\n    @param {Array} references\n\n    @return {DS.ManyArray}\n  */\n  createManyArray: function(type, references) {\n    var manyArray = DS.ManyArray.create({\n      type: type,\n      content: references,\n      store: this.store\n    });\n\n    references.forEach(function(reference) {\n      var arrays = this.recordArraysForReference(reference);\n      arrays.add(manyArray);\n    }, this);\n\n    return manyArray;\n  },\n\n  /**\n    @private\n\n    Register a RecordArray for a given type to be backed by\n    a filter function. This will cause the array to update\n    automatically when records of that type change attribute\n    values or states.\n\n    @param {DS.RecordArray} array\n    @param {Class} type\n    @param {Function} filter\n  */\n  registerFilteredRecordArray: function(array, type, filter) {\n    var recordArrays = this.filteredRecordArrays.get(type);\n    recordArrays.push(array);\n\n    this.updateFilter(array, type, filter);\n  },\n\n  // Internally, we maintain a map of all unloaded IDs requested by\n  // a ManyArray. As the adapter loads data into the store, the\n  // store notifies any interested ManyArrays. When the ManyArray's\n  // total number of loading records drops to zero, it becomes\n  // `isLoaded` and fires a `didLoad` event.\n  registerWaitingRecordArray: function(array, reference) {\n    var loadingRecordArrays = reference.loadingRecordArrays || [];\n    loadingRecordArrays.push(array);\n    reference.loadingRecordArrays = loadingRecordArrays;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_array_manager");minispade.register('ember-data/system/record_arrays', "(function() {/**\n  @module data\n  @submodule data-record-array\n*/\nminispade.require('ember-data/system/record_arrays/record_array');\nminispade.require('ember-data/system/record_arrays/filtered_record_array');\nminispade.require('ember-data/system/record_arrays/adapter_populated_record_array');\nminispade.require('ember-data/system/record_arrays/many_array');\n\n})();\n//@ sourceURL=ember-data/system/record_arrays");minispade.register('ember-data/system/record_arrays/adapter_populated_record_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module data\n  @submodule data-record-array\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  @class AdapterPopulatedRecordArray\n  @namespace DS\n  @extends DS.RecordArray\n  @constructor\n*/\nDS.AdapterPopulatedRecordArray = DS.RecordArray.extend({\n  query: null,\n\n  replace: function() {\n    var type = get(this, 'type').toString();\n    throw new Error(\"The result of a server query (on \" + type + \") is immutable.\");\n  },\n\n  load: function(references) {\n    this.setProperties({\n      content: Ember.A(references),\n      isLoaded: true\n    });\n\n    // TODO: does triggering didLoad event should be the last action of the runLoop?\n    Ember.run.once(this, 'trigger', 'didLoad');\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/adapter_populated_record_array");minispade.register('ember-data/system/record_arrays/filtered_record_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module data\n  @submodule data-record-array\n*/\n\nvar get = Ember.get;\n\n/**\n  @class FilteredRecordArray\n  @namespace DS\n  @extends DS.RecordArray\n  @constructor\n*/\nDS.FilteredRecordArray = DS.RecordArray.extend({\n  filterFunction: null,\n  isLoaded: true,\n\n  replace: function() {\n    var type = get(this, 'type').toString();\n    throw new Error(\"The result of a client-side filter (on \" + type + \") is immutable.\");\n  },\n\n  updateFilter: Ember.observer(function() {\n    var manager = get(this, 'manager');\n    manager.updateFilter(this, get(this, 'type'), get(this, 'filterFunction'));\n  }, 'filterFunction')\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/filtered_record_array");minispade.register('ember-data/system/record_arrays/many_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module data\n  @submodule data-record-array\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  A ManyArray is a RecordArray that represents the contents of a has-many\n  relationship.\n\n  The ManyArray is instantiated lazily the first time the relationship is\n  requested.\n\n  ### Inverses\n\n  Often, the relationships in Ember Data applications will have\n  an inverse. For example, imagine the following models are\n  defined:\n\n      App.Post = DS.Model.extend({\n        comments: DS.hasMany('App.Comment')\n      });\n\n      App.Comment = DS.Model.extend({\n        post: DS.belongsTo('App.Post')\n      });\n\n  If you created a new instance of `App.Post` and added\n  a `App.Comment` record to its `comments` has-many\n  relationship, you would expect the comment's `post`\n  property to be set to the post that contained\n  the has-many.\n\n  We call the record to which a relationship belongs the\n  relationship's _owner_.\n\n  @class ManyArray\n  @namespace DS\n  @extends DS.RecordArray\n  @constructor\n*/\nDS.ManyArray = DS.RecordArray.extend({\n  init: function() {\n    this._super.apply(this, arguments);\n    this._changesToSync = Ember.OrderedSet.create();\n  },\n\n  /**\n    @private\n\n    The record to which this relationship belongs.\n\n    @property {DS.Model}\n  */\n  owner: null,\n\n  /**\n    @private\n\n    `true` if the relationship is polymorphic, `false` otherwise.\n\n    @property {Boolean}\n  */\n  isPolymorphic: false,\n\n  // LOADING STATE\n\n  isLoaded: false,\n\n  loadingRecordsCount: function(count) {\n    this.loadingRecordsCount = count;\n  },\n\n  loadedRecord: function() {\n    this.loadingRecordsCount--;\n    if (this.loadingRecordsCount === 0) {\n      set(this, 'isLoaded', true);\n      this.trigger('didLoad');\n    }\n  },\n\n  fetch: function() {\n    var references = get(this, 'content'),\n        store = get(this, 'store'),\n        owner = get(this, 'owner');\n\n    store.fetchUnloadedReferences(references, owner);\n  },\n\n  // Overrides Ember.Array's replace method to implement\n  replaceContent: function(index, removed, added) {\n    // Map the array of record objects into an array of  client ids.\n    added = added.map(function(record) {\n      Ember.assert(\"You can only add records of \" + (get(this, 'type') && get(this, 'type').toString()) + \" to this relationship.\", !get(this, 'type') || (get(this, 'type').detectInstance(record)) );\n      return get(record, '_reference');\n    }, this);\n\n    this._super(index, removed, added);\n  },\n\n  arrangedContentDidChange: function() {\n    this.fetch();\n  },\n\n  arrayContentWillChange: function(index, removed, added) {\n    var owner = get(this, 'owner'),\n        name = get(this, 'name');\n\n    if (!owner._suspendedRelationships) {\n      // This code is the first half of code that continues inside\n      // of arrayContentDidChange. It gets or creates a change from\n      // the child object, adds the current owner as the old\n      // parent if this is the first time the object was removed\n      // from a ManyArray, and sets `newParent` to null.\n      //\n      // Later, if the object is added to another ManyArray,\n      // the `arrayContentDidChange` will set `newParent` on\n      // the change.\n      for (var i=index; i<index+removed; i++) {\n        var reference = get(this, 'content').objectAt(i);\n\n        var change = DS.RelationshipChange.createChange(owner.get('_reference'), reference, get(this, 'store'), {\n          parentType: owner.constructor,\n          changeType: \"remove\",\n          kind: \"hasMany\",\n          key: name\n        });\n\n        this._changesToSync.add(change);\n      }\n    }\n\n    return this._super.apply(this, arguments);\n  },\n\n  arrayContentDidChange: function(index, removed, added) {\n    this._super.apply(this, arguments);\n\n    var owner = get(this, 'owner'),\n        name = get(this, 'name'),\n        store = get(this, 'store');\n\n    if (!owner._suspendedRelationships) {\n      // This code is the second half of code that started in\n      // `arrayContentWillChange`. It gets or creates a change\n      // from the child object, and adds the current owner as\n      // the new parent.\n      for (var i=index; i<index+added; i++) {\n        var reference = get(this, 'content').objectAt(i);\n\n        var change = DS.RelationshipChange.createChange(owner.get('_reference'), reference, store, {\n          parentType: owner.constructor,\n          changeType: \"add\",\n          kind:\"hasMany\",\n          key: name\n        });\n        change.hasManyName = name;\n\n        this._changesToSync.add(change);\n      }\n\n      // We wait until the array has finished being\n      // mutated before syncing the OneToManyChanges created\n      // in arrayContentWillChange, so that the array\n      // membership test in the sync() logic operates\n      // on the final results.\n      this._changesToSync.forEach(function(change) {\n        change.sync();\n      });\n      DS.OneToManyChange.ensureSameTransaction(this._changesToSync, store);\n      this._changesToSync.clear();\n    }\n  },\n\n  // Create a child record within the owner\n  createRecord: function(hash, transaction) {\n    var owner = get(this, 'owner'),\n        store = get(owner, 'store'),\n        type = get(this, 'type'),\n        record;\n\n    Ember.assert(\"You can not create records of \" + (get(this, 'type') && get(this, 'type').toString()) + \" on this polymorphic relationship.\", !get(this, 'isPolymorphic'));\n\n    transaction = transaction || get(owner, 'transaction');\n\n    record = store.createRecord.call(store, type, hash, transaction);\n    this.pushObject(record);\n\n    return record;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/many_array");minispade.register('ember-data/system/record_arrays/record_array', "(function() {minispade.require(\"ember-data/system/mixins/load_promise\");\n\n/**\n*/\n\nvar get = Ember.get, set = Ember.set;\n\nvar LoadPromise = DS.LoadPromise; // system/mixins/load_promise\n\n/**\n  A record array is an array that contains records of a certain type. The record\n  array materializes records as needed when they are retrieved for the first\n  time. You should not create record arrays yourself. Instead, an instance of\n  DS.RecordArray or its subclasses will be returned by your application's store\n  in response to queries.\n\n  @module data\n  @submodule data-record-array\n  @main data-record-array\n\n  @class RecordArray\n  @namespace DS\n  @extends Ember.ArrayProxy\n  @uses Ember.Evented\n  @uses DS.LoadPromise\n*/\n\nDS.RecordArray = Ember.ArrayProxy.extend(LoadPromise, {\n  /**\n    The model type contained by this record array.\n\n    @type DS.Model\n  */\n  type: null,\n\n  // The array of client ids backing the record array. When a\n  // record is requested from the record array, the record\n  // for the client id at the same index is materialized, if\n  // necessary, by the store.\n  content: null,\n\n  isLoaded: false,\n  isUpdating: false,\n\n  // The store that created this record array.\n  store: null,\n\n  objectAtContent: function(index) {\n    var content = get(this, 'content'),\n        reference = content.objectAt(index),\n        store = get(this, 'store');\n\n    if (reference) {\n      return store.recordForReference(reference);\n    }\n  },\n\n  materializedObjectAt: function(index) {\n    var reference = get(this, 'content').objectAt(index);\n    if (!reference) { return; }\n\n    if (get(this, 'store').recordIsMaterialized(reference)) {\n      return this.objectAt(index);\n    }\n  },\n\n  update: function() {\n    if (get(this, 'isUpdating')) { return; }\n\n    var store = get(this, 'store'),\n        type = get(this, 'type');\n\n    store.fetchAll(type, this);\n  },\n\n  addReference: function(reference) {\n    get(this, 'content').addObject(reference);\n  },\n\n  removeReference: function(reference) {\n    get(this, 'content').removeObject(reference);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/record_array");minispade.register('ember-data/system/relationships', "(function() {/**\n  @module data\n  @submodule data-relationships\n*/\nminispade.require(\"ember-data/system/relationships/belongs_to\");\nminispade.require(\"ember-data/system/relationships/has_many\");\nminispade.require(\"ember-data/system/relationships/ext\");\n\n})();\n//@ sourceURL=ember-data/system/relationships");minispade.register('ember-data/system/relationships/belongs_to', "(function() {var get = Ember.get, set = Ember.set,\n    isNone = Ember.isNone;\n\nDS.belongsTo = function(type, options) {\n  Ember.assert(\"The first argument DS.belongsTo must be a model type or string, like DS.belongsTo(App.Person)\", !!type && (typeof type === 'string' || DS.Model.detect(type)));\n\n  options = options || {};\n\n  var meta = { type: type, isRelationship: true, options: options, kind: 'belongsTo' };\n\n  return Ember.computed(function(key, value) {\n    if (typeof type === 'string') {\n      type = get(this, type, false) || get(Ember.lookup, type);\n    }\n\n    if (arguments.length === 2) {\n      Ember.assert(\"You can only add a record of \" + type.toString() + \" to this relationship\", !value || type.detectInstance(value));\n      return value === undefined ? null : value;\n    }\n\n    var data = get(this, 'data').belongsTo,\n        store = get(this, 'store'), belongsTo;\n\n    belongsTo = data[key];\n\n    // TODO (tomdale) The value of the belongsTo in the data hash can be\n    // one of:\n    // 1. null/undefined\n    // 2. a record reference\n    // 3. a tuple returned by the serializer's polymorphism code\n    //\n    // We should really normalize #3 to be the same as #2 to reduce the\n    // complexity here.\n\n    if (isNone(belongsTo)) {\n      return null;\n    }\n\n    // The data has been normalized to a record reference, so\n    // just ask the store for the record for that reference,\n    // materializing it if necessary.\n    if (belongsTo.clientId) {\n      return store.recordForReference(belongsTo);\n    }\n\n    // The data has been normalized into a type/id pair by the\n    // serializer's polymorphism code.\n    return store.findById(belongsTo.type, belongsTo.id);\n  }).property('data').meta(meta);\n};\n\n/**\n  These observers observe all `belongsTo` relationships on the record. See\n  `relationships/ext` to see how these observers get their dependencies.\n\n*/\n\nDS.Model.reopen({\n  /** @private */\n  belongsToWillChange: Ember.beforeObserver(function(record, key) {\n    if (get(record, 'isLoaded')) {\n      var oldParent = get(record, key);\n\n      var childReference = get(record, '_reference'),\n          store = get(record, 'store');\n      if (oldParent){\n        var change = DS.RelationshipChange.createChange(childReference, get(oldParent, '_reference'), store, { key: key, kind:\"belongsTo\", changeType: \"remove\" });\n        change.sync();\n        this._changesToSync[key] = change;\n      }\n    }\n  }),\n\n  /** @private */\n  belongsToDidChange: Ember.immediateObserver(function(record, key) {\n    if (get(record, 'isLoaded')) {\n      var newParent = get(record, key);\n      if(newParent){\n        var childReference = get(record, '_reference'),\n            store = get(record, 'store');\n        var change = DS.RelationshipChange.createChange(childReference, get(newParent, '_reference'), store, { key: key, kind:\"belongsTo\", changeType: \"add\" });\n        change.sync();\n        if(this._changesToSync[key]){\n          DS.OneToManyChange.ensureSameTransaction([change, this._changesToSync[key]], store);\n        }\n      }\n    }\n    delete this._changesToSync[key];\n  })\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/belongs_to");minispade.register('ember-data/system/relationships/ext', "(function() {var get = Ember.get, set = Ember.set;\n\n/**\n  @private\n\n  This file defines several extensions to the base `DS.Model` class that\n  add support for one-to-many relationships.\n*/\n\nDS.Model.reopen({\n  // This Ember.js hook allows an object to be notified when a property\n  // is defined.\n  //\n  // In this case, we use it to be notified when an Ember Data user defines a\n  // belongs-to relationship. In that case, we need to set up observers for\n  // each one, allowing us to track relationship changes and automatically\n  // reflect changes in the inverse has-many array.\n  //\n  // This hook passes the class being set up, as well as the key and value\n  // being defined. So, for example, when the user does this:\n  //\n  //   DS.Model.extend({\n  //     parent: DS.belongsTo(App.User)\n  //   });\n  //\n  // This hook would be called with \"parent\" as the key and the computed\n  // property returned by `DS.belongsTo` as the value.\n  didDefineProperty: function(proto, key, value) {\n    // Check if the value being set is a computed property.\n    if (value instanceof Ember.Descriptor) {\n\n      // If it is, get the metadata for the relationship. This is\n      // populated by the `DS.belongsTo` helper when it is creating\n      // the computed property.\n      var meta = value.meta();\n\n      if (meta.isRelationship && meta.kind === 'belongsTo') {\n        Ember.addObserver(proto, key, null, 'belongsToDidChange');\n        Ember.addBeforeObserver(proto, key, null, 'belongsToWillChange');\n      }\n\n      if (meta.isAttribute) {\n        Ember.addObserver(proto, key, null, 'attributeDidChange');\n        Ember.addBeforeObserver(proto, key, null, 'attributeWillChange');\n      }\n\n      meta.parentType = proto.constructor;\n    }\n  }\n});\n\n/**\n  These DS.Model extensions add class methods that provide relationship\n  introspection abilities about relationships.\n\n  A note about the computed properties contained here:\n\n  **These properties are effectively sealed once called for the first time.**\n  To avoid repeatedly doing expensive iteration over a model's fields, these\n  values are computed once and then cached for the remainder of the runtime of\n  your application.\n\n  If your application needs to modify a class after its initial definition\n  (for example, using `reopen()` to add additional attributes), make sure you\n  do it before using your model with the store, which uses these properties\n  extensively.\n*/\n\nDS.Model.reopenClass({\n  /**\n    For a given relationship name, returns the model type of the relationship.\n\n    For example, if you define a model like this:\n\n        App.Post = DS.Model.extend({\n          comments: DS.hasMany(App.Comment)\n        });\n\n    Calling `App.Post.typeForRelationship('comments')` will return `App.Comment`.\n\n    @param {String} name the name of the relationship\n    @return {subclass of DS.Model} the type of the relationship, or undefined\n  */\n  typeForRelationship: function(name) {\n    var relationship = get(this, 'relationshipsByName').get(name);\n    return relationship && relationship.type;\n  },\n\n  inverseFor: function(name) {\n    var inverseType = this.typeForRelationship(name);\n\n    if (!inverseType) { return null; }\n\n    var options = this.metaForProperty(name).options;\n    var inverseName, inverseKind;\n\n    if (options.inverse) {\n      inverseName = options.inverse;\n      inverseKind = Ember.get(inverseType, 'relationshipsByName').get(inverseName).kind;\n    } else {\n      var possibleRelationships = findPossibleInverses(this, inverseType);\n\n      if (possibleRelationships.length === 0) { return null; }\n\n      Ember.assert(\"You defined the '\" + name + \"' relationship on \" + this + \", but multiple possible inverse relationships of type \" + this + \" were found on \" + inverseType + \".\", possibleRelationships.length === 1);\n\n      inverseName = possibleRelationships[0].name;\n      inverseKind = possibleRelationships[0].kind;\n    }\n\n    function findPossibleInverses(type, inverseType, possibleRelationships) {\n      possibleRelationships = possibleRelationships || [];\n\n      var relationshipMap = get(inverseType, 'relationships');\n      if (!relationshipMap) { return; }\n\n      var relationships = relationshipMap.get(type);\n      if (relationships) {\n        possibleRelationships.push.apply(possibleRelationships, relationshipMap.get(type));\n      }\n\n      if (type.superclass) {\n        findPossibleInverses(type.superclass, inverseType, possibleRelationships);\n      }\n\n      return possibleRelationships;\n    }\n\n    return {\n      type: inverseType,\n      name: inverseName,\n      kind: inverseKind\n    };\n  },\n\n  /**\n    The model's relationships as a map, keyed on the type of the\n    relationship. The value of each entry is an array containing a descriptor\n    for each relationship with that type, describing the name of the relationship\n    as well as the type.\n\n    For example, given the following model definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n          posts: DS.hasMany(App.Post)\n        });\n\n    This computed property would return a map describing these\n    relationships, like this:\n\n        var relationships = Ember.get(App.Blog, 'relationships');\n        relationships.get(App.User);\n        //=> [ { name: 'users', kind: 'hasMany' },\n        //     { name: 'owner', kind: 'belongsTo' } ]\n        relationships.get(App.Post);\n        //=> [ { name: 'posts', kind: 'hasMany' } ]\n\n    @type Ember.Map\n    @readOnly\n  */\n  relationships: Ember.computed(function() {\n    var map = new Ember.MapWithDefault({\n      defaultValue: function() { return []; }\n    });\n\n    // Loop through each computed property on the class\n    this.eachComputedProperty(function(name, meta) {\n\n      // If the computed property is a relationship, add\n      // it to the map.\n      if (meta.isRelationship) {\n        if (typeof meta.type === 'string') {\n          meta.type = Ember.get(Ember.lookup, meta.type);\n        }\n\n        var relationshipsForType = map.get(meta.type);\n\n        relationshipsForType.push({ name: name, kind: meta.kind });\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A hash containing lists of the model's relationships, grouped\n    by the relationship kind. For example, given a model with this\n    definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n\n          posts: DS.hasMany(App.Post)\n        });\n\n    This property would contain the following:\n\n       var relationshipNames = Ember.get(App.Blog, 'relationshipNames');\n       relationshipNames.hasMany;\n       //=> ['users', 'posts']\n       relationshipNames.belongsTo;\n       //=> ['owner']\n\n    @type Object\n    @readOnly\n  */\n  relationshipNames: Ember.computed(function() {\n    var names = { hasMany: [], belongsTo: [] };\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        names[meta.kind].push(name);\n      }\n    });\n\n    return names;\n  }),\n\n  /**\n    An array of types directly related to a model. Each type will be\n    included once, regardless of the number of relationships it has with\n    the model.\n\n    For example, given a model with this definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n          posts: DS.hasMany(App.Post)\n        });\n\n    This property would contain the following:\n\n       var relatedTypes = Ember.get(App.Blog, 'relatedTypes');\n       //=> [ App.User, App.Post ]\n\n    @type Ember.Array\n    @readOnly\n  */\n  relatedTypes: Ember.computed(function() {\n    var type,\n        types = Ember.A([]);\n\n    // Loop through each computed property on the class,\n    // and create an array of the unique types involved\n    // in relationships\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        type = meta.type;\n\n        if (typeof type === 'string') {\n          type = get(this, type, false) || get(Ember.lookup, type);\n        }\n\n        Ember.assert(\"You specified a hasMany (\" + meta.type + \") on \" + meta.parentType + \" but \" + meta.type + \" was not found.\",  type);\n\n        if (!types.contains(type)) {\n          Ember.assert(\"Trying to sideload \" + name + \" on \" + this.toString() + \" but the type doesn't exist.\", !!type);\n          types.push(type);\n        }\n      }\n    });\n\n    return types;\n  }),\n\n  /**\n    A map whose keys are the relationships of a model and whose values are\n    relationship descriptors.\n\n    For example, given a model with this\n    definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n\n          posts: DS.hasMany(App.Post)\n        });\n\n    This property would contain the following:\n\n       var relationshipsByName = Ember.get(App.Blog, 'relationshipsByName');\n       relationshipsByName.get('users');\n       //=> { key: 'users', kind: 'hasMany', type: App.User }\n       relationshipsByName.get('owner');\n       //=> { key: 'owner', kind: 'belongsTo', type: App.User }\n\n    @type Ember.Map\n    @readOnly\n  */\n  relationshipsByName: Ember.computed(function() {\n    var map = Ember.Map.create(), type;\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        meta.key = name;\n        type = meta.type;\n\n        if (typeof type === 'string') {\n          type = get(this, type, false) || get(Ember.lookup, type);\n          meta.type = type;\n        }\n\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A map whose keys are the fields of the model and whose values are strings\n    describing the kind of the field. A model's fields are the union of all of its\n    attributes and relationships.\n\n    For example:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n\n          posts: DS.hasMany(App.Post),\n\n          title: DS.attr('string')\n        });\n\n        var fields = Ember.get(App.Blog, 'fields');\n        fields.forEach(function(field, kind) {\n          console.log(field, kind);\n        });\n\n        // prints:\n        // users, hasMany\n        // owner, belongsTo\n        // posts, hasMany\n        // title, attribute\n\n    @type Ember.Map\n    @readOnly\n  */\n  fields: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        map.set(name, meta.kind);\n      } else if (meta.isAttribute) {\n        map.set(name, 'attribute');\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    Given a callback, iterates over each of the relationships in the model,\n    invoking the callback with the name of each relationship and its relationship\n    descriptor.\n\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelationship: function(callback, binding) {\n    get(this, 'relationshipsByName').forEach(function(name, relationship) {\n      callback.call(binding, name, relationship);\n    });\n  },\n\n  /**\n    Given a callback, iterates over each of the types related to a model,\n    invoking the callback with the related type's class. Each type will be\n    returned just once, regardless of how many different relationships it has\n    with a model.\n\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelatedType: function(callback, binding) {\n    get(this, 'relatedTypes').forEach(function(type) {\n      callback.call(binding, type);\n    });\n  }\n});\n\nDS.Model.reopen({\n  /**\n    Given a callback, iterates over each of the relationships in the model,\n    invoking the callback with the name of each relationship and its relationship\n    descriptor.\n\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelationship: function(callback, binding) {\n    this.constructor.eachRelationship(callback, binding);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/ext");minispade.register('ember-data/system/relationships/has_many', "(function() {var get = Ember.get, set = Ember.set, forEach = Ember.EnumerableUtils.forEach;\nminispade.require(\"ember-data/system/model/model\");\n\nvar hasRelationship = function(type, options) {\n  options = options || {};\n\n  var meta = { type: type, isRelationship: true, options: options, kind: 'hasMany' };\n\n  return Ember.computed(function(key, value) {\n    var data = get(this, 'data').hasMany,\n        store = get(this, 'store'),\n        ids, relationship;\n\n    if (typeof type === 'string') {\n      type = get(this, type, false) || get(Ember.lookup, type);\n    }\n\n    //ids can be references or opaque token\n    //(e.g. `{url: '/relationship'}`) that will be passed to the adapter\n    ids = data[key];\n\n    relationship = store.findMany(type, ids, this, meta);\n    set(relationship, 'owner', this);\n    set(relationship, 'name', key);\n    set(relationship, 'isPolymorphic', options.polymorphic);\n\n    return relationship;\n  }).property().meta(meta);\n};\n\nDS.hasMany = function(type, options) {\n  Ember.assert(\"The type passed to DS.hasMany must be defined\", !!type);\n  return hasRelationship(type, options);\n};\n\nfunction clearUnmaterializedHasMany(record, relationship) {\n  var store = get(record, 'store'),\n      data = get(record, 'data').hasMany;\n\n  var references = data[relationship.key];\n\n  if (!references) { return; }\n\n  var inverse = record.constructor.inverseFor(relationship.key);\n\n  if (inverse) {\n    forEach(references, function(reference) {\n      var childRecord;\n\n      if (childRecord = reference.record) {\n        record.suspendRelationshipObservers(function() {\n          set(childRecord, inverse.name, null);\n        });\n      }\n    });\n  }\n}\n\nDS.Model.reopen({\n  clearHasMany: function(relationship) {\n    var hasMany = this.cacheFor(relationship.name);\n\n    if (hasMany) {\n      hasMany.clear();\n    } else {\n      clearUnmaterializedHasMany(this, relationship);\n    }\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/has_many");minispade.register('ember-data/system/serializer', "(function() {var get = Ember.get, set = Ember.set, map = Ember.ArrayPolyfills.map, isNone = Ember.isNone;\n\nfunction mustImplement(name) {\n  return function() {\n    throw new Ember.Error(\"Your serializer \" + this.toString() + \" does not implement the required method \" + name);\n  };\n}\n\n/**\n  A serializer is responsible for serializing and deserializing a group of\n  records.\n\n  `DS.Serializer` is an abstract base class designed to help you build a\n  serializer that can read to and write from any serialized form.  While most\n  applications will use `DS.JSONSerializer`, which reads and writes JSON, the\n  serializer architecture allows your adapter to transmit things like XML,\n  strings, or custom binary data.\n\n  Typically, your application's `DS.Adapter` is responsible for both creating a\n  serializer as well as calling the appropriate methods when it needs to\n  materialize data or serialize a record.\n\n  The serializer API is designed as a series of layered hooks that you can\n  override to customize any of the individual steps of serialization and\n  deserialization.\n\n  The hooks are organized by the three responsibilities of the serializer:\n\n  1. Determining naming conventions\n  2. Serializing records into a serialized form\n  3. Deserializing records from a serialized form\n\n  Because Ember Data lazily materializes records, the deserialization\n  step, and therefore the hooks you implement, are split into two phases:\n\n  1. Extraction, where the serialized forms for multiple records are\n     extracted from a single payload. The IDs of each record are also\n     extracted for indexing.\n  2. Materialization, where a newly-created record has its attributes\n     and relationships initialized based on the serialized form loaded\n     by the adapter.\n\n  Additionally, a serializer can convert values from their JavaScript\n  versions into their serialized versions via a declarative API.\n\n  ## Naming Conventions\n\n  One of the most common uses of the serializer is to map attribute names\n  from the serialized form to your `DS.Model`. For example, in your model,\n  you may have an attribute called `firstName`:\n\n  ```javascript\n  App.Person = DS.Model.extend({\n    firstName: DS.attr('string')\n  });\n  ```\n\n  However, because the web API your adapter is communicating with is\n  legacy, it calls this attribute `FIRST_NAME`.\n\n  You can determine the attribute name used in the serialized form\n  by implementing `keyForAttributeName`:\n\n  ```javascript\n  keyForAttributeName: function(type, name) {\n    return name.underscore.toUpperCase();\n  }\n  ```\n\n  If your attribute names are not predictable, you can re-map them\n  one-by-one using the adapter's `map` API:\n\n  ```javascript\n  App.Adapter.map('App.Person', {\n    firstName: { key: '*API_USER_FIRST_NAME*' }\n  });\n  ```\n\n  This API will also work for relationships and primary keys. For\n  example:\n\n  ```javascript\n  App.Adapter.map('App.Person', {\n    primaryKey: '_id'\n  });\n  ```\n\n  ## Serialization\n\n  During the serialization process, a record or records are converted\n  from Ember.js objects into their serialized form.\n\n  These methods are designed in layers, like a delicious 7-layer\n  cake (but with fewer layers).\n\n  The main entry point for serialization is the `serialize`\n  method, which takes the record and options.\n\n  The `serialize` method is responsible for:\n\n  * turning the record's attributes (`DS.attr`) into\n    attributes on the JSON object.\n  * optionally adding the record's ID onto the hash\n  * adding relationships (`DS.hasMany` and `DS.belongsTo`)\n    to the JSON object.\n\n  Depending on the backend, the serializer can choose\n  whether to include the `hasMany` or `belongsTo`\n  relationships on the JSON hash.\n\n  For very custom serialization, you can implement your\n  own `serialize` method. In general, however, you will want\n  to override the hooks described below.\n\n  ### Adding the ID\n\n  The default `serialize` will optionally call your serializer's\n  `addId` method with the JSON hash it is creating, the\n  record's type, and the record's ID. The `serialize` method\n  will not call `addId` if the record's ID is undefined.\n\n  Your adapter must specifically request ID inclusion by\n  passing `{ includeId: true }` as an option to `serialize`.\n\n  NOTE: You may not want to include the ID when updating an\n  existing record, because your server will likely disallow\n  changing an ID after it is created, and the PUT request\n  itself will include the record's identification.\n\n  By default, `addId` will:\n\n  1. Get the primary key name for the record by calling\n     the serializer's `primaryKey` with the record's type.\n     Unless you override the `primaryKey` method, this\n     will be `'id'`.\n  2. Assign the record's ID to the primary key in the\n     JSON hash being built.\n\n  If your backend expects a JSON object with the primary\n  key at the root, you can just override the `primaryKey`\n  method on your serializer subclass.\n\n  Otherwise, you can override the `addId` method for\n  more specialized handling.\n\n  ### Adding Attributes\n\n  By default, the serializer's `serialize` method will call\n  `addAttributes` with the JSON object it is creating\n  and the record to serialize.\n\n  The `addAttributes` method will then call `addAttribute`\n  in turn, with the JSON object, the record to serialize,\n  the attribute's name and its type.\n\n  Finally, the `addAttribute` method will serialize the\n  attribute:\n\n  1. It will call `keyForAttributeName` to determine\n     the key to use in the JSON hash.\n  2. It will get the value from the record.\n  3. It will call `serializeValue` with the attribute's\n     value and attribute type to convert it into a\n     JSON-compatible value. For example, it will convert a\n     Date into a String.\n\n  If your backend expects a JSON object with attributes as\n  keys at the root, you can just override the `serializeValue`\n  and `keyForAttributeName` methods in your serializer\n  subclass and let the base class do the heavy lifting.\n\n  If you need something more specialized, you can probably\n  override `addAttribute` and let the default `addAttributes`\n  handle the nitty gritty.\n\n  ### Adding Relationships\n\n  By default, `serialize` will call your serializer's\n  `addRelationships` method with the JSON object that is\n  being built and the record being serialized. The default\n  implementation of this method is to loop over all of the\n  relationships defined on your record type and:\n\n  * If the relationship is a `DS.hasMany` relationship,\n    call `addHasMany` with the JSON object, the record\n    and a description of the relationship.\n  * If the relationship is a `DS.belongsTo` relationship,\n    call `addBelongsTo` with the JSON object, the record\n    and a description of the relationship.\n\n  The relationship description has the following keys:\n\n  * `type`: the class of the associated information (the\n    first parameter to `DS.hasMany` or `DS.belongsTo`)\n  * `kind`: either `hasMany` or `belongsTo`\n\n  The relationship description may get additional\n  information in the future if more capabilities or\n  relationship types are added. However, it will\n  remain backwards-compatible, so the mere existence\n  of new features should not break existing adapters.\n\n  @module data\n  @submodule data-serializer\n  @main data-serializer\n\n  @class Serializer\n  @namespace DS\n  @extends Ember.Object\n  @constructor\n*/\n\nDS.Serializer = Ember.Object.extend({\n  init: function() {\n    this.mappings = Ember.Map.create();\n    this.aliases = Ember.Map.create();\n    this.configurations = Ember.Map.create();\n    this.globalConfigurations = {};\n  },\n\n  extract: mustImplement('extract'),\n  extractMany: mustImplement('extractMany'),\n  extractId: mustImplement('extractId'),\n  extractAttribute: mustImplement('extractAttribute'),\n  extractHasMany: mustImplement('extractHasMany'),\n  extractBelongsTo: mustImplement('extractBelongsTo'),\n\n  extractRecordRepresentation: function(loader, type, data, shouldSideload) {\n    var prematerialized = {}, reference;\n\n    if (shouldSideload) {\n      reference = loader.sideload(type, data);\n    } else {\n      reference = loader.load(type, data);\n    }\n\n    this.eachEmbeddedHasMany(type, function(name, relationship) {\n      var embeddedData = this.extractEmbeddedData(data, this.keyFor(relationship));\n      if (!isNone(embeddedData)) {\n        this.extractEmbeddedHasMany(loader, relationship, embeddedData, reference, prematerialized);\n      }\n    }, this);\n\n    this.eachEmbeddedBelongsTo(type, function(name, relationship) {\n      var embeddedData = this.extractEmbeddedData(data, this.keyFor(relationship));\n      if (!isNone(embeddedData)) {\n        this.extractEmbeddedBelongsTo(loader, relationship, embeddedData, reference, prematerialized);\n      }\n    }, this);\n\n    loader.prematerialize(reference, prematerialized);\n\n    return reference;\n  },\n\n  extractEmbeddedHasMany: function(loader, relationship, array, parent, prematerialized) {\n    var references = map.call(array, function(item) {\n      if (!item) { return; }\n\n      var foundType = this.extractEmbeddedType(relationship, item),\n          reference = this.extractRecordRepresentation(loader, foundType, item, true);\n\n      // If the embedded record should also be saved back when serializing the parent,\n      // make sure we set its parent since it will not have an ID.\n      var embeddedType = this.embeddedType(parent.type, relationship.key);\n      if (embeddedType === 'always') {\n        reference.parent = parent;\n      }\n\n      // If the embedded children have an inverse belongs-to, set the\n      // inverse to the current record in their prematerialized data.\n      var parentType = relationship.parentType,\n          inverse = parentType.inverseFor(relationship.key);\n\n      if (inverse) {\n        var inverseName = inverse.name;\n        reference.prematerialized[inverseName] = parent;\n      }\n\n      return reference;\n    }, this);\n\n    prematerialized[relationship.key] = references;\n  },\n\n  extractEmbeddedBelongsTo: function(loader, relationship, data, parent, prematerialized) {\n    var foundType = this.extractEmbeddedType(relationship, data),\n        reference = this.extractRecordRepresentation(loader, foundType, data, true);\n    prematerialized[relationship.key] = reference;\n\n    // If the embedded record should also be saved back when serializing the parent,\n    // make sure we set its parent since it will not have an ID.\n    var embeddedType = this.embeddedType(parent.type, relationship.key);\n    if (embeddedType === 'always') {\n      reference.parent = parent;\n    }\n  },\n\n  /**\n    A hook you can use to customize how the record's type is extracted from\n    the serialized data.\n\n    The `extractEmbeddedType` hook is called with:\n\n    * the relationship\n    * the serialized representation of the record\n\n    By default, it returns the type of the relationship.\n\n    @method extractEmbeddedType\n    @param {Object} relationship an object representing the relationship\n    @param {any} data the serialized representation of the record\n  */\n  extractEmbeddedType: function(relationship, data) {\n    return relationship.type;\n  },\n\n  /**\n    A hook you need to implement in order to extract\n    the data associated with an embedded record.\n\n    @param {any} data the serialized representation of the record\n    @param {String} key the key that represents the embedded record\n   */\n  extractEmbeddedData: mustImplement(),\n\n  //.......................\n  //. SERIALIZATION HOOKS\n  //.......................\n\n  /**\n    The main entry point for serializing a record. While you can consider this\n    a hook that can be overridden in your serializer, you will have to manually\n    handle serialization. For most cases, there are more granular hooks that you\n    can override.\n\n    If overriding this method, these are the responsibilities that you will need\n    to implement yourself:\n\n    * If the option hash contains `includeId`, add the record's ID to the serialized form.\n      By default, `serialize` calls `addId` if appropriate.\n    * If the option hash contains `includeType`, add the record's type to the serialized form.\n    * Add the record's attributes to the serialized form. By default, `serialize` calls\n      `addAttributes`.\n    * Add the record's relationships to the serialized form. By default, `serialize` calls\n      `addRelationships`.\n\n    @method serialize\n    @param {DS.Model} record the record to serialize\n    @param {Object} [options] a hash of options\n    @returns {any} the serialized form of the record\n  */\n  serialize: function(record, options) {\n    options = options || {};\n\n    var serialized = this.createSerializedForm(), id;\n\n    if (options.includeId) {\n      if (id = get(record, 'id')) {\n        this._addId(serialized, record.constructor, id);\n      }\n    }\n\n    if (options.includeType) {\n      this.addType(serialized, record.constructor);\n    }\n\n    this.addAttributes(serialized, record);\n    this.addRelationships(serialized, record);\n\n    return serialized;\n  },\n\n  /**\n    @private\n\n    Given an attribute type and value, convert the value into the\n    serialized form using the transform registered for that type.\n\n    @method serializeValue\n    @param {any} value the value to convert to the serialized form\n    @param {String} attributeType the registered type (e.g. `string`\n      or `boolean`)\n    @returns {any} the serialized form of the value\n  */\n  serializeValue: function(value, attributeType) {\n    var transform = this.transforms ? this.transforms[attributeType] : null;\n\n    Ember.assert(\"You tried to use an attribute type (\" + attributeType + \") that has not been registered\", transform);\n    return transform.serialize(value);\n  },\n\n  /**\n    A hook you can use to normalize IDs before adding them to the\n    serialized representation.\n\n    Because the store coerces all IDs to strings for consistency,\n    this is the opportunity for the serializer to, for example,\n    convert numerical IDs back into number form.\n\n    @param {String} id the id from the record\n    @returns {any} the serialized representation of the id\n  */\n  serializeId: function(id) {\n    if (isNaN(id)) { return id; }\n    return +id;\n  },\n\n  /**\n    A hook you can use to change how attributes are added to the serialized\n    representation of a record.\n\n    By default, `addAttributes` simply loops over all of the attributes of the\n    passed record, maps the attribute name to the key for the serialized form,\n    and invokes any registered transforms on the value. It then invokes the\n    more granular `addAttribute` with the key and transformed value.\n\n    Since you can override `keyForAttributeName`, `addAttribute`, and register\n    custom transforms, you should rarely need to override this hook.\n\n    @method addAttributes\n    @param {any} data the serialized representation that is being built\n    @param {DS.Model} record the record to serialize\n  */\n  addAttributes: function(data, record) {\n    record.eachAttribute(function(name, attribute) {\n      this._addAttribute(data, record, name, attribute.type);\n    }, this);\n  },\n\n  /**\n    A hook you can use to customize how the key/value pair is added to\n    the serialized data.\n\n    @method addAttribute\n    @param {any} serialized the serialized form being built\n    @param {String} key the key to add to the serialized data\n    @param {any} value the value to add to the serialized data\n  */\n  addAttribute: mustImplement('addAttribute'),\n\n  /**\n    A hook you can use to customize how the record's id is added to\n    the serialized data.\n\n    The `addId` hook is called with:\n\n    * the serialized representation being built\n    * the resolved primary key (taking configurations and the\n      `primaryKey` hook into consideration)\n    * the serialized id (after calling the `serializeId` hook)\n\n    @method addId\n    @param {any} data the serialized representation that is being built\n    @param {String} key the resolved primary key\n    @param {id} id the serialized id\n  */\n  addId: mustImplement('addId'),\n\n  /**\n    A hook you can use to customize how the record's type is added to\n    the serialized data.\n\n    The `addType` hook is called with:\n\n    * the serialized representation being built\n    * the serialized id (after calling the `serializeId` hook)\n\n    @method addType\n    @param {any} data the serialized representation that is being built\n    @param {DS.Model subclass} type the type of the record\n  */\n  addType: Ember.K,\n\n  /**\n    Creates an empty hash that will be filled in by the hooks called from the\n    `serialize()` method.\n\n    @method createSerializedForm\n    @return {Object}\n  */\n  createSerializedForm: function() {\n    return {};\n  },\n\n  /**\n    A hook you can use to change how relationships are added to the serialized\n    representation of a record.\n\n    By default, `addRelationships` loops over all of the relationships of the\n    passed record, maps the relationship names to the key for the serialized form,\n    and then invokes the public `addBelongsTo` and `addHasMany` hooks.\n\n    Since you can override `keyForBelongsTo`, `keyForHasMany`, `addBelongsTo`,\n    `addHasMany`, and register mappings, you should rarely need to override this\n    hook.\n\n    @method addRelationships\n    @param {any} data the serialized representation that is being built\n    @param {DS.Model} record the record to serialize\n  */\n  addRelationships: function(data, record) {\n    record.eachRelationship(function(name, relationship) {\n      if (relationship.kind === 'belongsTo') {\n        this._addBelongsTo(data, record, name, relationship);\n      } else if (relationship.kind === 'hasMany') {\n        this._addHasMany(data, record, name, relationship);\n      }\n    }, this);\n  },\n\n  /**\n    A hook you can use to add a `belongsTo` relationship to the\n    serialized representation.\n\n    The specifics of this hook are very adapter-specific, so there\n    is no default implementation. You can see `DS.JSONSerializer`\n    for an example of an implementation of the `addBelongsTo` hook.\n\n    The `belongsTo` relationship object has the following properties:\n\n    * **type** a subclass of DS.Model that is the type of the\n      relationship. This is the first parameter to DS.belongsTo\n    * **options** the options passed to the call to DS.belongsTo\n    * **kind** always `belongsTo`\n\n    Additional properties may be added in the future.\n\n    @method addBelongsTo\n    @param {any} data the serialized representation that is being built\n    @param {DS.Model} record the record to serialize\n    @param {String} key the key for the serialized object\n    @param {Object} relationship an object representing the relationship\n  */\n  addBelongsTo: mustImplement('addBelongsTo'),\n\n  /**\n    A hook you can use to add a `hasMany` relationship to the\n    serialized representation.\n\n    The specifics of this hook are very adapter-specific, so there\n    is no default implementation. You may not need to implement this,\n    for example, if your backend only expects relationships on the\n    child of a one to many relationship.\n\n    The `hasMany` relationship object has the following properties:\n\n    * **type** a subclass of DS.Model that is the type of the\n      relationship. This is the first parameter to DS.hasMany\n    * **options** the options passed to the call to DS.hasMany\n    * **kind** always `hasMany`\n\n    Additional properties may be added in the future.\n\n    @method addHasMany\n    @param {any} data the serialized representation that is being built\n    @param {DS.Model} record the record to serialize\n    @param {String} key the key for the serialized object\n    @param {Object} relationship an object representing the relationship\n  */\n  addHasMany: mustImplement('addHasMany'),\n\n  /**\n    NAMING CONVENTIONS\n\n    The most commonly overridden APIs of the serializer are\n    the naming convention methods:\n\n    * `keyForAttributeName`: converts a camelized attribute name\n      into a key in the adapter-provided data hash. For example,\n      if the model's attribute name was `firstName`, and the\n      server used underscored names, you would return `first_name`.\n    * `primaryKey`: returns the key that should be used to\n      extract the id from the adapter-provided data hash. It is\n      also used when serializing a record.\n  */\n\n  /**\n    A hook you can use in your serializer subclass to customize\n    how an unmapped attribute name is converted into a key.\n\n    By default, this method returns the `name` parameter.\n\n    For example, if the attribute names in your JSON are underscored,\n    you will want to convert them into JavaScript conventional\n    camelcase:\n\n    ```javascript\n    App.MySerializer = DS.Serializer.extend({\n      // ...\n\n      keyForAttributeName: function(type, name) {\n        return name.camelize();\n      }\n    });\n    ```\n\n    @method keyForAttributeName\n    @param {DS.Model subclass} type the type of the record with\n      the attribute name `name`\n    @param {String} name the attribute name to convert into a key\n\n    @returns {String} the key\n  */\n  keyForAttributeName: function(type, name) {\n    return name;\n  },\n\n  /**\n    A hook you can use in your serializer to specify a conventional\n    primary key.\n\n    By default, this method will return the string `id`.\n\n    In general, you should not override this hook to specify a special\n    primary key for an individual type; use `configure` instead.\n\n    For example, if your primary key is always `__id__`:\n\n    ```javascript\n    App.MySerializer = DS.Serializer.extend({\n      // ...\n      primaryKey: function(type) {\n        return '__id__';\n      }\n    });\n    ```\n\n    In another example, if the primary key always includes the\n    underscored version of the type before the string `id`:\n\n    ```javascript\n    App.MySerializer = DS.Serializer.extend({\n      // ...\n      primaryKey: function(type) {\n        // If the type is `BlogPost`, this will return\n        // `blog_post_id`.\n        var typeString = type.toString().split(\".\")[1].underscore();\n        return typeString + \"_id\";\n      }\n    });\n    ```\n\n    @method primaryKey\n    @param {DS.Model subclass} type\n    @returns {String} the primary key for the type\n  */\n  primaryKey: function(type) {\n    return \"id\";\n  },\n\n  /**\n    A hook you can use in your serializer subclass to customize\n    how an unmapped `belongsTo` relationship is converted into\n    a key.\n\n    By default, this method calls `keyForAttributeName`, so if\n    your naming convention is uniform across attributes and\n    relationships, you can use the default here and override\n    just `keyForAttributeName` as needed.\n\n    For example, if the `belongsTo` names in your JSON always\n    begin with `BT_` (e.g. `BT_posts`), you can strip out the\n    `BT_` prefix:\"\n\n    ```javascript\n    App.MySerializer = DS.Serializer.extend({\n      // ...\n      keyForBelongsTo: function(type, name) {\n        return name.match(/^BT_(.*)$/)[1].camelize();\n      }\n    });\n    ```\n\n    @method keyForBelongsTo\n    @param {DS.Model subclass} type the type of the record with\n      the `belongsTo` relationship.\n    @param {String} name the relationship name to convert into a key\n\n    @returns {String} the key\n  */\n  keyForBelongsTo: function(type, name) {\n    return this.keyForAttributeName(type, name);\n  },\n\n  /**\n    A hook you can use in your serializer subclass to customize\n    how an unmapped `hasMany` relationship is converted into\n    a key.\n\n    By default, this method calls `keyForAttributeName`, so if\n    your naming convention is uniform across attributes and\n    relationships, you can use the default here and override\n    just `keyForAttributeName` as needed.\n\n    For example, if the `hasMany` names in your JSON always\n    begin with the \"table name\" for the current type (e.g.\n    `post_comments`), you can strip out the prefix:\"\n\n    ```javascript\n    App.MySerializer = DS.Serializer.extend({\n      // ...\n      keyForHasMany: function(type, name) {\n        // if your App.BlogPost has many App.BlogComment, the key from\n        // the server would look like: `blog_post_blog_comments`\n        //\n        // 1. Convert the type into a string and underscore the\n        //    second part (App.BlogPost -> blog_post)\n        // 2. Extract the part after `blog_post_` (`blog_comments`)\n        // 3. Underscore it, to become `blogComments`\n        var typeString = type.toString().split(\".\")[1].underscore();\n        return name.match(new RegExp(\"^\" + typeString + \"_(.*)$\"))[1].camelize();\n      }\n    });\n    ```\n\n    @method keyForHasMany\n    @param {DS.Model subclass} type the type of the record with\n      the `belongsTo` relationship.\n    @param {String} name the relationship name to convert into a key\n\n    @returns {String} the key\n  */\n  keyForHasMany: function(type, name) {\n    return this.keyForAttributeName(type, name);\n  },\n\n  //.........................\n  //. MATERIALIZATION HOOKS\n  //.........................\n\n  materialize: function(record, serialized, prematerialized) {\n    var id;\n    if (Ember.isNone(get(record, 'id'))) {\n      if (prematerialized && prematerialized.hasOwnProperty('id')) {\n        id = prematerialized.id;\n      } else {\n        id = this.extractId(record.constructor, serialized);\n      }\n      record.materializeId(id);\n    }\n\n    this.materializeAttributes(record, serialized, prematerialized);\n    this.materializeRelationships(record, serialized, prematerialized);\n  },\n\n  deserializeValue: function(value, attributeType) {\n    var transform = this.transforms ? this.transforms[attributeType] : null;\n\n    Ember.assert(\"You tried to use a attribute type (\" + attributeType + \") that has not been registered\", transform);\n    return transform.deserialize(value);\n  },\n\n  materializeAttributes: function(record, serialized, prematerialized) {\n    record.eachAttribute(function(name, attribute) {\n      if (prematerialized && prematerialized.hasOwnProperty(name)) {\n        record.materializeAttribute(name, prematerialized[name]);\n      } else {\n        this.materializeAttribute(record, serialized, name, attribute.type);\n      }\n    }, this);\n  },\n\n  materializeAttribute: function(record, serialized, attributeName, attributeType) {\n    var value = this.extractAttribute(record.constructor, serialized, attributeName);\n    value = this.deserializeValue(value, attributeType);\n\n    record.materializeAttribute(attributeName, value);\n  },\n\n  materializeRelationships: function(record, hash, prematerialized) {\n    record.eachRelationship(function(name, relationship) {\n      if (relationship.kind === 'hasMany') {\n        if (prematerialized && prematerialized.hasOwnProperty(name)) {\n          var tuplesOrReferencesOrOpaque = this._convertPrematerializedHasMany(relationship.type, prematerialized[name]);\n          record.materializeHasMany(name, tuplesOrReferencesOrOpaque);\n        } else {\n          this.materializeHasMany(name, record, hash, relationship, prematerialized);\n        }\n      } else if (relationship.kind === 'belongsTo') {\n        if (prematerialized && prematerialized.hasOwnProperty(name)) {\n          var tupleOrReference = this._convertTuple(relationship.type, prematerialized[name]);\n          record.materializeBelongsTo(name, tupleOrReference);\n        } else {\n          this.materializeBelongsTo(name, record, hash, relationship, prematerialized);\n        }\n      }\n    }, this);\n  },\n\n  materializeHasMany: function(name, record, hash, relationship) {\n    var type = record.constructor,\n        key = this._keyForHasMany(type, relationship.key),\n        idsOrTuples = this.extractHasMany(type, hash, key),\n        tuples = idsOrTuples;\n\n    if(idsOrTuples && Ember.isArray(idsOrTuples)) {\n      tuples = this._convertTuples(relationship.type, idsOrTuples);\n    }\n\n    record.materializeHasMany(name, tuples);\n  },\n\n  materializeBelongsTo: function(name, record, hash, relationship) {\n    var type = record.constructor,\n        key = this._keyForBelongsTo(type, relationship.key),\n        idOrTuple,\n        tuple = null;\n\n    if(relationship.options && relationship.options.polymorphic) {\n      idOrTuple = this.extractBelongsToPolymorphic(type, hash, key);\n    } else {\n      idOrTuple = this.extractBelongsTo(type, hash, key);\n    }\n\n    if(!isNone(idOrTuple)) {\n      tuple = this._convertTuple(relationship.type, idOrTuple);\n    }\n\n    record.materializeBelongsTo(name, tuple);\n  },\n\n  _convertPrematerializedHasMany: function(type, prematerializedHasMany) {\n    var tuplesOrReferencesOrOpaque;\n    if( typeof prematerializedHasMany === 'string' ) {\n      tuplesOrReferencesOrOpaque = prematerializedHasMany;\n    } else {\n      tuplesOrReferencesOrOpaque = this._convertTuples(type, prematerializedHasMany);\n    }\n    return tuplesOrReferencesOrOpaque;\n  },\n\n  _convertTuples: function(type, idsOrTuples) {\n    return map.call(idsOrTuples, function(idOrTuple) {\n      return this._convertTuple(type, idOrTuple);\n    }, this);\n  },\n\n  _convertTuple: function(type, idOrTuple) {\n    var foundType;\n\n    if (typeof idOrTuple === 'object') {\n      if (DS.Model.detect(idOrTuple.type)) {\n        return idOrTuple;\n      } else {\n        foundType = this.typeFromAlias(idOrTuple.type);\n        Ember.assert(\"Unable to resolve type \" + idOrTuple.type + \".  You may need to configure your serializer aliases.\", !!foundType);\n\n        return {id: idOrTuple.id, type: foundType};\n      }\n    }\n    return {id: idOrTuple, type: type};\n  },\n\n  /**\n    @private\n\n    This method is called to get the primary key for a given\n    type.\n\n    If a primary key configuration exists for this type, this\n    method will return the configured value. Otherwise, it will\n    call the public `primaryKey` hook.\n\n    @method _primaryKey\n    @param {DS.Model subclass} type\n    @returns {String} the primary key for the type\n  */\n  _primaryKey: function(type) {\n    var config = this.configurationForType(type),\n        primaryKey = config && config.primaryKey;\n\n    if (primaryKey) {\n      return primaryKey;\n    } else {\n      return this.primaryKey(type);\n    }\n  },\n\n  /**\n    @private\n\n    This method looks up the key for the attribute name and transforms the\n    attribute's value using registered transforms.\n\n    Specifically:\n\n    1. Look up the key for the attribute name. If available, this will use\n       any registered mappings. Otherwise, it will invoke the public\n       `keyForAttributeName` hook.\n    2. Get the value from the record using the `attributeName`.\n    3. Transform the value using registered transforms for the `attributeType`.\n    4. Invoke the public `addAttribute` hook with the hash, key, and\n       transformed value.\n\n    @method _addAttribute\n    @param {any} data the serialized representation being built\n    @param {DS.Model} record the record to serialize\n    @param {String} attributeName the name of the attribute on the record\n    @param {String} attributeType the type of the attribute (e.g. `string`\n      or `boolean`)\n  */\n  _addAttribute: function(data, record, attributeName, attributeType) {\n    var key = this._keyForAttributeName(record.constructor, attributeName);\n    var value = get(record, attributeName);\n\n    this.addAttribute(data, key, this.serializeValue(value, attributeType));\n  },\n\n  /**\n    @private\n\n    This method looks up the primary key for the `type` and invokes\n    `serializeId` on the `id`.\n\n    It then invokes the public `addId` hook with the primary key and\n    the serialized id.\n\n    @method _addId\n    @param {any} data the serialized representation that is being built\n    @param {Ember.Model subclass} type\n    @param {any} id the materialized id from the record\n  */\n  _addId: function(hash, type, id) {\n    var primaryKey = this._primaryKey(type);\n\n    this.addId(hash, primaryKey, this.serializeId(id));\n  },\n\n  /**\n    @private\n\n    This method is called to get a key used in the data from\n    an attribute name. It first checks for any mappings before\n    calling the public hook `keyForAttributeName`.\n\n    @method _keyForAttributeName\n    @param {DS.Model subclass} type the type of the record with\n      the attribute name `name`\n    @param {String} name the attribute name to convert into a key\n\n    @returns {String} the key\n  */\n  _keyForAttributeName: function(type, name) {\n    return this._keyFromMappingOrHook('keyForAttributeName', type, name);\n  },\n\n  /**\n    @private\n\n    This method is called to get a key used in the data from\n    a belongsTo relationship. It first checks for any mappings before\n    calling the public hook `keyForBelongsTo`.\n\n    @method _keyForBelongsTo\n    @param {DS.Model subclass} type the type of the record with\n      the `belongsTo` relationship.\n    @param {String} name the relationship name to convert into a key\n\n    @returns {String} the key\n  */\n  _keyForBelongsTo: function(type, name) {\n    return this._keyFromMappingOrHook('keyForBelongsTo', type, name);\n  },\n\n  keyFor: function(description) {\n    var type = description.parentType,\n        name = description.key;\n\n    switch (description.kind) {\n      case 'belongsTo':\n        return this._keyForBelongsTo(type, name);\n      case 'hasMany':\n        return this._keyForHasMany(type, name);\n    }\n  },\n\n  /**\n    @private\n\n    This method is called to get a key used in the data from\n    a hasMany relationship. It first checks for any mappings before\n    calling the public hook `keyForHasMany`.\n\n    @method _keyForHasMany\n    @param {DS.Model subclass} type the type of the record with\n      the `hasMany` relationship.\n    @param {String} name the relationship name to convert into a key\n\n    @returns {String} the key\n  */\n  _keyForHasMany: function(type, name) {\n    return this._keyFromMappingOrHook('keyForHasMany', type, name);\n  },\n  /**\n    @private\n\n    This method converts the relationship name to a key for serialization,\n    and then invokes the public `addBelongsTo` hook.\n\n    @method _addBelongsTo\n    @param {any} data the serialized representation that is being built\n    @param {DS.Model} record the record to serialize\n    @param {String} name the relationship name\n    @param {Object} relationship an object representing the relationship\n  */\n  _addBelongsTo: function(data, record, name, relationship) {\n    var key = this._keyForBelongsTo(record.constructor, name);\n    this.addBelongsTo(data, record, key, relationship);\n  },\n\n  /**\n    @private\n\n    This method converts the relationship name to a key for serialization,\n    and then invokes the public `addHasMany` hook.\n\n    @method _addHasMany\n    @param {any} data the serialized representation that is being built\n    @param {DS.Model} record the record to serialize\n    @param {String} name the relationship name\n    @param {Object} relationship an object representing the relationship\n  */\n  _addHasMany: function(data, record, name, relationship) {\n    var key = this._keyForHasMany(record.constructor, name);\n    this.addHasMany(data, record, key, relationship);\n  },\n\n  /**\n    @private\n\n    An internal method that handles checking whether a mapping\n    exists for a particular attribute or relationship name before\n    calling the public hooks.\n\n    If a mapping is found, and the mapping has a key defined,\n    use that instead of invoking the hook.\n\n    @method _keyFromMappingOrHook\n    @param {String} publicMethod the public hook to invoke if\n      a mapping is not found (e.g. `keyForAttributeName`)\n    @param {DS.Model subclass} type the type of the record with\n      the attribute or relationship name.\n    @param {String} name the attribute or relationship name to\n      convert into a key\n  */\n  _keyFromMappingOrHook: function(publicMethod, type, name) {\n    var key = this.mappingOption(type, name, 'key');\n\n    if (key) {\n      return key;\n    } else {\n      return this[publicMethod](type, name);\n    }\n  },\n\n  /**\n    TRANSFORMS\n  */\n\n  registerTransform: function(type, transform) {\n    this.transforms[type] = transform;\n  },\n\n  registerEnumTransform: function(type, objects) {\n    var transform = {\n      deserialize: function(serialized) {\n        return Ember.A(objects).objectAt(serialized);\n      },\n      serialize: function(deserialized) {\n        return Ember.EnumerableUtils.indexOf(objects, deserialized);\n      },\n      values: objects\n    };\n    this.registerTransform(type, transform);\n  },\n\n  /**\n    MAPPING CONVENIENCE\n  */\n\n  map: function(type, mappings) {\n    this.mappings.set(type, mappings);\n  },\n\n  configure: function(type, configuration) {\n    if (type && !configuration) {\n      Ember.merge(this.globalConfigurations, type);\n      return;\n    }\n\n    var config, alias;\n\n    if (configuration.alias) {\n      alias = configuration.alias;\n      this.aliases.set(alias, type);\n      delete configuration.alias;\n    }\n\n    config = Ember.create(this.globalConfigurations);\n    Ember.merge(config, configuration);\n\n    this.configurations.set(type, config);\n  },\n\n  typeFromAlias: function(alias) {\n    this._completeAliases();\n    return this.aliases.get(alias);\n  },\n\n  mappingForType: function(type) {\n    this._reifyMappings();\n    return this.mappings.get(type) || {};\n  },\n\n  configurationForType: function(type) {\n    this._reifyConfigurations();\n    return this.configurations.get(type) || this.globalConfigurations;\n  },\n\n  _completeAliases: function() {\n    this._pluralizeAliases();\n    this._reifyAliases();\n  },\n\n  _pluralizeAliases: function() {\n    if (this._didPluralizeAliases) { return; }\n\n    var aliases = this.aliases,\n        sideloadMapping = this.aliases.sideloadMapping,\n        plural,\n        self = this;\n\n    aliases.forEach(function(key, type) {\n      plural = self.pluralize(key);\n      Ember.assert(\"The '\" + key + \"' alias has already been defined\", !aliases.get(plural));\n      aliases.set(plural, type);\n    });\n\n    // This map is only for backward compatibility with the `sideloadAs` option.\n    if (sideloadMapping) {\n      sideloadMapping.forEach(function(key, type) {\n        Ember.assert(\"The '\" + key + \"' alias has already been defined\", !aliases.get(key) || (aliases.get(key)===type) );\n        aliases.set(key, type);\n      });\n      delete this.aliases.sideloadMapping;\n    }\n\n    this._didPluralizeAliases = true;\n  },\n\n  _reifyAliases: function() {\n    if (this._didReifyAliases) { return; }\n\n    var aliases = this.aliases,\n        reifiedAliases = Ember.Map.create(),\n        foundType;\n\n    aliases.forEach(function(key, type) {\n      if (typeof type === 'string') {\n        foundType = Ember.get(Ember.lookup, type);\n        Ember.assert(\"Could not find model at path \" + key, type);\n\n        reifiedAliases.set(key, foundType);\n      } else {\n        reifiedAliases.set(key, type);\n      }\n    });\n\n    this.aliases = reifiedAliases;\n    this._didReifyAliases = true;\n  },\n\n  _reifyMappings: function() {\n    if (this._didReifyMappings) { return; }\n\n    var mappings = this.mappings,\n        reifiedMappings = Ember.Map.create();\n\n    mappings.forEach(function(key, mapping) {\n      if (typeof key === 'string') {\n        var type = Ember.get(Ember.lookup, key);\n        Ember.assert(\"Could not find model at path \" + key, type);\n\n        reifiedMappings.set(type, mapping);\n      } else {\n        reifiedMappings.set(key, mapping);\n      }\n    });\n\n    this.mappings = reifiedMappings;\n\n    this._didReifyMappings = true;\n  },\n\n  _reifyConfigurations: function() {\n    if (this._didReifyConfigurations) { return; }\n\n    var configurations = this.configurations,\n        reifiedConfigurations = Ember.Map.create();\n\n    configurations.forEach(function(key, mapping) {\n      if (typeof key === 'string' && key !== 'plurals') {\n        var type = Ember.get(Ember.lookup, key);\n        Ember.assert(\"Could not find model at path \" + key, type);\n\n        reifiedConfigurations.set(type, mapping);\n      } else {\n        reifiedConfigurations.set(key, mapping);\n      }\n    });\n\n    this.configurations = reifiedConfigurations;\n\n    this._didReifyConfigurations = true;\n  },\n\n  mappingOption: function(type, name, option) {\n    var mapping = this.mappingForType(type)[name];\n\n    return mapping && mapping[option];\n  },\n\n  configOption: function(type, option) {\n    var config = this.configurationForType(type);\n\n    return config[option];\n  },\n\n  // EMBEDDED HELPERS\n\n  embeddedType: function(type, name) {\n    return this.mappingOption(type, name, 'embedded');\n  },\n\n  eachEmbeddedRecord: function(record, callback, binding) {\n    this.eachEmbeddedBelongsToRecord(record, callback, binding);\n    this.eachEmbeddedHasManyRecord(record, callback, binding);\n  },\n\n  eachEmbeddedBelongsToRecord: function(record, callback, binding) {\n    this.eachEmbeddedBelongsTo(record.constructor, function(name, relationship, embeddedType) {\n      var embeddedRecord = get(record, name);\n      if (embeddedRecord) { callback.call(binding, embeddedRecord, embeddedType); }\n    });\n  },\n\n  eachEmbeddedHasManyRecord: function(record, callback, binding) {\n    this.eachEmbeddedHasMany(record.constructor, function(name, relationship, embeddedType) {\n      var array = get(record, name);\n      for (var i=0, l=get(array, 'length'); i<l; i++) {\n        callback.call(binding, array.objectAt(i), embeddedType);\n      }\n    });\n  },\n\n  eachEmbeddedHasMany: function(type, callback, binding) {\n    this.eachEmbeddedRelationship(type, 'hasMany', callback, binding);\n  },\n\n  eachEmbeddedBelongsTo: function(type, callback, binding) {\n    this.eachEmbeddedRelationship(type, 'belongsTo', callback, binding);\n  },\n\n  eachEmbeddedRelationship: function(type, kind, callback, binding) {\n    type.eachRelationship(function(name, relationship) {\n      var embeddedType = this.embeddedType(type, name);\n\n      if (embeddedType) {\n        if (relationship.kind === kind) {\n          callback.call(binding, name, relationship, embeddedType);\n        }\n      }\n    }, this);\n  },\n\n  // HELPERS\n\n  // define a plurals hash in your subclass to define\n  // special-case pluralization\n  pluralize: function(name) {\n    var plurals = this.configurations.get('plurals');\n    return (plurals && plurals[name]) || name + \"s\";\n  },\n\n  // use the same plurals hash to determine\n  // special-case singularization\n  singularize: function(name) {\n    var plurals = this.configurations.get('plurals');\n    if (plurals) {\n      for (var i in plurals) {\n        if (plurals[i] === name) {\n          return i;\n        }\n      }\n    }\n    if (name.lastIndexOf('s') === name.length - 1) {\n      return name.substring(0, name.length - 1);\n    } else {\n      return name;\n    }\n  }\n});\n\n\n})();\n//@ sourceURL=ember-data/system/serializer");minispade.register('ember-data/system/store', "(function() {/*globals Ember*/\n/*jshint eqnull:true*/\nminispade.require(\"ember-data/system/record_arrays\");\nminispade.require(\"ember-data/system/transaction\");\nminispade.require(\"ember-data/system/mixins/mappable\");\n\n/**\n  @module data\n  @submodule data-store\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar once = Ember.run.once;\nvar isNone = Ember.isNone;\nvar forEach = Ember.EnumerableUtils.forEach;\nvar map = Ember.EnumerableUtils.map;\n\n// These values are used in the data cache when clientIds are\n// needed but the underlying data has not yet been loaded by\n// the server.\nvar UNLOADED = 'unloaded';\nvar LOADING = 'loading';\nvar MATERIALIZED = { materialized: true };\nvar CREATED = { created: true };\n\n// Implementors Note:\n//\n//   The variables in this file are consistently named according to the following\n//   scheme:\n//\n//   * +id+ means an identifier managed by an external source, provided inside\n//     the data provided by that source. These are always coerced to be strings\n//     before being used internally.\n//   * +clientId+ means a transient numerical identifier generated at runtime by\n//     the data store. It is important primarily because newly created objects may\n//     not yet have an externally generated id.\n//   * +reference+ means a record reference object, which holds metadata about a\n//     record, even if it has not yet been fully materialized.\n//   * +type+ means a subclass of DS.Model.\n\n// Used by the store to normalize IDs entering the store.  Despite the fact\n// that developers may provide IDs as numbers (e.g., `store.find(Person, 1)`),\n// it is important that internally we use strings, since IDs may be serialized\n// and lose type information.  For example, Ember's router may put a record's\n// ID into the URL, and if we later try to deserialize that URL and find the\n// corresponding record, we will not know if it is a string or a number.\nvar coerceId = function(id) {\n  return id == null ? null : id+'';\n};\n\n\n/**\n  The store contains all of the data for records loaded from the server.\n  It is also responsible for creating instances of DS.Model that wrap\n  the individual data for a record, so that they can be bound to in your\n  Handlebars templates.\n\n  Define your application's store like this:\n\n       MyApp.Store = DS.Store.extend();\n\n  Most Ember.js applications will only have a single `DS.Store` that is\n  automatically created by their `Ember.Application`.\n\n  You can retrieve models from the store in several ways. To retrieve a record\n  for a specific id, use `DS.Model`'s `find()` method:\n\n       var person = App.Person.find(123);\n\n  If your application has multiple `DS.Store` instances (an unusual case), you can\n  specify which store should be used:\n\n      var person = store.find(App.Person, 123);\n\n  In general, you should retrieve models using the methods on `DS.Model`; you should\n  rarely need to interact with the store directly.\n\n  By default, the store will talk to your backend using a standard REST mechanism.\n  You can customize how the store talks to your backend by specifying a custom adapter:\n\n       MyApp.store = DS.Store.create({\n         adapter: 'MyApp.CustomAdapter'\n       });\n\n  You can learn more about writing a custom adapter by reading the `DS.Adapter`\n  documentation.\n\n  @class Store\n  @namespace DS\n  @extends Ember.Object\n  @uses DS._Mappable\n  @constructor\n*/\nDS.Store = Ember.Object.extend(DS._Mappable, {\n\n  /**\n    Many methods can be invoked without specifying which store should be used.\n    In those cases, the first store created will be used as the default. If\n    an application has multiple stores, it should specify which store to use\n    when performing actions, such as finding records by ID.\n\n    The init method registers this store as the default if none is specified.\n  */\n  init: function() {\n    if (!get(DS, 'defaultStore') || get(this, 'isDefaultStore')) {\n      set(DS, 'defaultStore', this);\n    }\n\n    // internal bookkeeping; not observable\n    this.typeMaps = {};\n    this.recordArrayManager = DS.RecordArrayManager.create({\n      store: this\n    });\n    this.relationshipChanges = {};\n\n    set(this, 'currentTransaction', this.transaction());\n    set(this, 'defaultTransaction', this.transaction());\n  },\n\n  /**\n    Returns a new transaction scoped to this store. This delegates\n    responsibility for invoking the adapter's commit mechanism to\n    a transaction.\n\n    Transaction are responsible for tracking changes to records\n    added to them, and supporting `commit` and `rollback`\n    functionality. Committing a transaction invokes the store's\n    adapter, while rolling back a transaction reverses all\n    changes made to records added to the transaction.\n\n    A store has an implicit (default) transaction, which tracks changes\n    made to records not explicitly added to a transaction.\n\n    @see {DS.Transaction}\n    @returns DS.Transaction\n  */\n  transaction: function() {\n    return DS.Transaction.create({ store: this });\n  },\n\n  /**\n    @private\n\n    Instructs the store to materialize the data for a given record.\n\n    To materialize a record, the store first retrieves the opaque data that was\n    passed to either `load()` or `loadMany()`. Then, the data and the record\n    are passed to the adapter's `materialize()` method, which allows the adapter\n    to translate arbitrary data structures from the adapter into the normalized\n    form the record expects.\n\n    The adapter's `materialize()` method will invoke `materializeAttribute()`,\n    `materializeHasMany()` and `materializeBelongsTo()` on the record to\n    populate it with normalized values.\n\n    @param {DS.Model} record\n  */\n  materializeData: function(record) {\n    var reference = get(record, '_reference'),\n        data = reference.data,\n        adapter = this.adapterForType(record.constructor);\n\n    reference.data = MATERIALIZED;\n\n    record.setupData();\n\n    if (data !== CREATED) {\n      // Instructs the adapter to extract information from the\n      // opaque data and materialize the record's attributes and\n      // relationships.\n      adapter.materialize(record, data, reference.prematerialized);\n    }\n  },\n\n  /**\n    The adapter to use to communicate to a backend server or other persistence layer.\n\n    This can be specified as an instance, a class, or a property path that specifies\n    where the adapter can be located.\n\n    @property {DS.Adapter|String}\n  */\n  adapter: Ember.computed(function(){\n    if (!Ember.testing) {\n      Ember.debug(\"A custom DS.Adapter was not provided as the 'Adapter' property of your application's Store. The default (DS.RESTAdapter) will be used.\");\n    }\n\n    return 'DS.RESTAdapter';\n  }).property(),\n\n\n  /**\n    @private\n\n    Returns a JSON representation of the record using the adapter's\n    serialization strategy. This method exists primarily to enable\n    a record, which has access to its store (but not the store's\n    adapter) to provide a `serialize()` convenience.\n\n    The available options are:\n\n    * `includeId`: `true` if the record's ID should be included in\n      the JSON representation\n\n    @param {DS.Model} record the record to serialize\n    @param {Object} options an options hash\n  */\n  serialize: function(record, options) {\n    return this.adapterForType(record.constructor).serialize(record, options);\n  },\n\n  /**\n    @private\n\n    This property returns the adapter, after resolving a possible\n    property path.\n\n    If the supplied `adapter` was a class, or a String property\n    path resolved to a class, this property will instantiate the\n    class.\n\n    This property is cacheable, so the same instance of a specified\n    adapter class should be used for the lifetime of the store.\n\n    @returns DS.Adapter\n  */\n  _adapter: Ember.computed(function() {\n    var adapter = get(this, 'adapter');\n    if (typeof adapter === 'string') {\n      adapter = get(this, adapter, false) || get(Ember.lookup, adapter);\n    }\n\n    if (DS.Adapter.detect(adapter)) {\n      adapter = adapter.create();\n    }\n\n    return adapter;\n  }).property('adapter'),\n\n  /**\n    @private\n\n    A monotonically increasing number to be used to uniquely identify\n    data and records.\n\n    It starts at 1 so other parts of the code can test for truthiness\n    when provided a `clientId` instead of having to explicitly test\n    for undefined.\n  */\n  clientIdCounter: 1,\n\n  // .....................\n  // . CREATE NEW RECORD .\n  // .....................\n\n  /**\n    Create a new record in the current store. The properties passed\n    to this method are set on the newly created record.\n\n    Note: The third `transaction` property is for internal use only.\n    If you want to create a record inside of a given transaction,\n    use `transaction.createRecord()` instead of `store.createRecord()`.\n\n    @method createRecord\n    @param {subclass of DS.Model} type\n    @param {Object} properties a hash of properties to set on the\n      newly created record.\n    @returns DS.Model\n  */\n  createRecord: function(type, properties, transaction) {\n    properties = properties || {};\n\n    // Create a new instance of the model `type` and put it\n    // into the specified `transaction`. If no transaction is\n    // specified, the default transaction will be used.\n    var record = type._create({\n      store: this\n    });\n\n    transaction = transaction || get(this, 'defaultTransaction');\n\n    // adoptRecord is an internal API that allows records to move\n    // into a transaction without assertions designed for app\n    // code. It is used here to ensure that regardless of new\n    // restrictions on the use of the public `transaction.add()`\n    // API, we will always be able to insert new records into\n    // their transaction.\n    transaction.adoptRecord(record);\n\n    // `id` is a special property that may not be a `DS.attr`\n    var id = properties.id;\n\n    // If the passed properties do not include a primary key,\n    // give the adapter an opportunity to generate one. Typically,\n    // client-side ID generators will use something like uuid.js\n    // to avoid conflicts.\n\n    if (isNone(id)) {\n      var adapter = this.adapterForType(type);\n\n      if (adapter && adapter.generateIdForRecord) {\n        id = coerceId(adapter.generateIdForRecord(this, record));\n        properties.id = id;\n      }\n    }\n\n    // Coerce ID to a string\n    id = coerceId(id);\n\n    // Create a new `clientId` and associate it with the\n    // specified (or generated) `id`. Since we don't have\n    // any data for the server yet (by definition), store\n    // the sentinel value CREATED as the data for this\n    // clientId. If we see this value later, we will skip\n    // materialization.\n    var reference = this.createReference(type, id);\n    reference.data = CREATED;\n\n    // Now that we have a reference, attach it to the record we\n    // just created.\n    set(record, '_reference', reference);\n    reference.record = record;\n\n    // Move the record out of its initial `empty` state into\n    // the `loaded` state.\n    record.loadedData();\n\n    record.setupData();\n\n    // Set the properties specified on the record.\n    record.setProperties(properties);\n\n    // Resolve record promise\n    Ember.run(record, 'resolve', record);\n\n    return record;\n  },\n\n  // .................\n  // . DELETE RECORD .\n  // .................\n\n  /**\n    For symmetry, a record can be deleted via the store.\n\n    @param {DS.Model} record\n  */\n  deleteRecord: function(record) {\n    record.deleteRecord();\n  },\n\n  /**\n    For symmetry, a record can be unloaded via the store.\n\n    @param {DS.Model} record\n  */\n  unloadRecord: function(record) {\n    record.unloadRecord();\n  },\n\n  // ................\n  // . FIND RECORDS .\n  // ................\n\n  /**\n    This is the main entry point into finding records. The first parameter to\n    this method is always a subclass of `DS.Model`.\n\n    You can use the `find` method on a subclass of `DS.Model` directly if your\n    application only has one store. For example, instead of\n    `store.find(App.Person, 1)`, you could say `App.Person.find(1)`.\n\n    ---\n\n    To find a record by ID, pass the `id` as the second parameter:\n\n        store.find(App.Person, 1);\n        App.Person.find(1);\n\n    If the record with that `id` had not previously been loaded, the store will\n    return an empty record immediately and ask the adapter to find the data by\n    calling the adapter's `find` method.\n\n    The `find` method will always return the same object for a given type and\n    `id`. To check whether the adapter has populated a record, you can check\n    its `isLoaded` property.\n\n    ---\n\n    To find all records for a type, call `find` with no additional parameters:\n\n        store.find(App.Person);\n        App.Person.find();\n\n    This will return a `RecordArray` representing all known records for the\n    given type and kick off a request to the adapter's `findAll` method to load\n    any additional records for the type.\n\n    The `RecordArray` returned by `find()` is live. If any more records for the\n    type are added at a later time through any mechanism, it will automatically\n    update to reflect the change.\n\n    ---\n\n    To find a record by a query, call `find` with a hash as the second\n    parameter:\n\n        store.find(App.Person, { page: 1 });\n        App.Person.find({ page: 1 });\n\n    This will return a `RecordArray` immediately, but it will always be an\n    empty `RecordArray` at first. It will call the adapter's `findQuery`\n    method, which will populate the `RecordArray` once the server has returned\n    results.\n\n    You can check whether a query results `RecordArray` has loaded by checking\n    its `isLoaded` property.\n\n    @method find\n    @param {DS.Model} type\n    @param {Object|String|Integer|null} id\n  */\n  find: function(type, id) {\n    if (id === undefined) {\n      return this.findAll(type);\n    }\n\n    // We are passed a query instead of an id.\n    if (Ember.typeOf(id) === 'object') {\n      return this.findQuery(type, id);\n    }\n\n    return this.findById(type, coerceId(id));\n  },\n\n  /**\n    @private\n\n    This method returns a record for a given type and id combination.\n\n    If the store has never seen this combination of type and id before, it\n    creates a new `clientId` with the LOADING sentinel and asks the adapter to\n    load the data.\n\n    If the store has seen the combination, this method delegates to\n    `getByReference`.\n  */\n  findById: function(type, id) {\n    var reference;\n\n    if (this.hasReferenceForId(type, id)) {\n      reference = this.referenceForId(type, id);\n\n      if (reference.data !== UNLOADED) {\n        return this.recordForReference(reference);\n      }\n    }\n\n    if (!reference) {\n      reference = this.createReference(type, id);\n    }\n\n    reference.data = LOADING;\n\n    // create a new instance of the model type in the\n    // 'isLoading' state\n    var record = this.materializeRecord(reference);\n\n    if (reference.data === LOADING) {\n      // let the adapter set the data, possibly async\n      var adapter = this.adapterForType(type),\n          store = this;\n\n      Ember.assert(\"You tried to find a record but you have no adapter (for \" + type + \")\", adapter);\n      Ember.assert(\"You tried to find a record but your adapter does not implement `find`\", adapter.find);\n\n      var thenable = adapter.find(this, type, id);\n\n      if (thenable && thenable.then) {\n        thenable.then(null /* for future use */, function(error) {\n          store.recordWasError(record);\n        });\n      }\n    }\n\n    return record;\n  },\n\n  reloadRecord: function(record) {\n    var type = record.constructor,\n        adapter = this.adapterForType(type),\n        store = this,\n        id = get(record, 'id');\n\n    Ember.assert(\"You cannot update a record without an ID\", id);\n    Ember.assert(\"You tried to update a record but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to update a record but your adapter does not implement `find`\", adapter.find);\n\n    var thenable = adapter.find(this, type, id);\n\n    if (thenable && thenable.then) {\n      thenable.then(null /* for future use */, function(error) {\n        store.recordWasError(record);\n      });\n    }\n  },\n\n  /**\n    @private\n\n    This method returns a record for a given record refeence.\n\n    If no record for the reference has yet been materialized, this method will\n    materialize a new `DS.Model` instance. This allows adapters to eagerly load\n    large amounts of data into the store, and avoid incurring the cost of\n    creating models until they are requested.\n\n    In short, it's a convenient way to get a record for a known\n    record reference, materializing it if necessary.\n\n    @param {Object} reference\n    @returns {DS.Model}\n  */\n  recordForReference: function(reference) {\n    var record = reference.record;\n\n    if (!record) {\n      // create a new instance of the model type in the\n      // 'isLoading' state\n      record = this.materializeRecord(reference);\n    }\n\n    return record;\n  },\n\n  /**\n    @private\n\n    Given an array of `reference`s, determines which of those\n    `clientId`s has not yet been loaded.\n\n    In preparation for loading, this method also marks any unloaded\n    `clientId`s as loading.\n  */\n  unloadedReferences: function(references) {\n    var unloadedReferences = [];\n\n    for (var i=0, l=references.length; i<l; i++) {\n      var reference = references[i];\n\n      if (reference.data === UNLOADED) {\n        unloadedReferences.push(reference);\n        reference.data = LOADING;\n      }\n    }\n\n    return unloadedReferences;\n  },\n\n  /**\n    @private\n\n    This method is the entry point that relationships use to update\n    themselves when their underlying data changes.\n\n    First, it determines which of its `reference`s are still unloaded,\n    then invokes `findMany` on the adapter.\n  */\n  fetchUnloadedReferences: function(references, owner) {\n    var unloadedReferences = this.unloadedReferences(references);\n    this.fetchMany(unloadedReferences, owner);\n  },\n\n  /**\n    @private\n\n    This method takes a list of `reference`s, groups the `reference`s by type,\n    converts the `reference`s into IDs, and then invokes the adapter's `findMany`\n    method.\n\n    The `reference`s are grouped by type to invoke `findMany` on adapters\n    for each unique type in `reference`s.\n\n    It is used both by a brand new relationship (via the `findMany`\n    method) or when the data underlying an existing relationship\n    changes (via the `fetchUnloadedReferences` method).\n  */\n  fetchMany: function(references, owner) {\n    if (!references.length) { return; }\n\n    // Group By Type\n    var referencesByTypeMap = Ember.MapWithDefault.create({\n      defaultValue: function() { return Ember.A(); }\n    });\n    forEach(references, function(reference) {\n      referencesByTypeMap.get(reference.type).push(reference);\n    });\n\n    forEach(referencesByTypeMap, function(type) {\n      var references = referencesByTypeMap.get(type),\n          ids = map(references, function(reference) { return reference.id; });\n\n      var adapter = this.adapterForType(type);\n\n      Ember.assert(\"You tried to load many records but you have no adapter (for \" + type + \")\", adapter);\n      Ember.assert(\"You tried to load many records but your adapter does not implement `findMany`\", adapter.findMany);\n\n      adapter.findMany(this, type, ids, owner);\n    }, this);\n  },\n\n  hasReferenceForId: function(type, id) {\n    id = coerceId(id);\n\n    return !!this.typeMapFor(type).idToReference[id];\n  },\n\n  referenceForId: function(type, id) {\n    id = coerceId(id);\n\n    // Check to see if we have seen this type/id pair before.\n    var reference = this.typeMapFor(type).idToReference[id];\n\n    // If not, create a reference for it but don't populate it\n    // with any data yet.\n    if (!reference) {\n      reference = this.createReference(type, id);\n      reference.data = UNLOADED;\n    }\n\n    return reference;\n  },\n\n  /**\n    @private\n\n    `findMany` is the entry point that relationships use to generate a\n    new `ManyArray` for the list of IDs specified by the server for\n    the relationship.\n\n    Its responsibilities are:\n\n    * convert the IDs into clientIds\n    * determine which of the clientIds still need to be loaded\n    * create a new ManyArray whose content is *all* of the clientIds\n    * notify the ManyArray of the number of its elements that are\n      already loaded\n    * insert the unloaded references into the `loadingRecordArrays`\n      bookkeeping structure, which will allow the `ManyArray` to know\n      when all of its loading elements are loaded from the server.\n    * ask the adapter to load the unloaded elements, by invoking\n      findMany with the still-unloaded IDs.\n  */\n  findMany: function(type, idsOrReferencesOrOpaque, record, relationship) {\n    // 1. Determine which of the client ids need to be loaded\n    // 2. Create a new ManyArray whose content is ALL of the clientIds\n    // 3. Decrement the ManyArray's counter by the number of loaded clientIds\n    // 4. Put the ManyArray into our bookkeeping data structure, keyed on\n    //    the needed clientIds\n    // 5. Ask the adapter to load the records for the unloaded clientIds (but\n    //    convert them back to ids)\n\n    if (!Ember.isArray(idsOrReferencesOrOpaque)) {\n      var adapter = this.adapterForType(type);\n\n      if (adapter && adapter.findHasMany) {\n        adapter.findHasMany(this, record, relationship, idsOrReferencesOrOpaque);\n      } else if (idsOrReferencesOrOpaque !== undefined) {\n        Ember.assert(\"You tried to load many records but you have no adapter (for \" + type + \")\", adapter);\n        Ember.assert(\"You tried to load many records but your adapter does not implement `findHasMany`\", adapter.findHasMany);\n      }\n\n      return this.recordArrayManager.createManyArray(type, Ember.A());\n    }\n\n    // Coerce server IDs into Record Reference\n    var references = map(idsOrReferencesOrOpaque, function(reference) {\n      if (typeof reference !== 'object' && reference !== null) {\n        return this.referenceForId(type, reference);\n      }\n\n      return reference;\n    }, this);\n\n    var unloadedReferences = this.unloadedReferences(references),\n        manyArray = this.recordArrayManager.createManyArray(type, Ember.A(references)),\n        loadingRecordArrays = this.loadingRecordArrays,\n        reference, clientId, i, l;\n\n    // Start the decrementing counter on the ManyArray at the number of\n    // records we need to load from the adapter\n    manyArray.loadingRecordsCount(unloadedReferences.length);\n\n    if (unloadedReferences.length) {\n      for (i=0, l=unloadedReferences.length; i<l; i++) {\n        reference = unloadedReferences[i];\n\n        // keep track of the record arrays that a given loading record\n        // is part of. This way, if the same record is in multiple\n        // ManyArrays, all of their loading records counters will be\n        // decremented when the adapter provides the data.\n        this.recordArrayManager.registerWaitingRecordArray(manyArray, reference);\n      }\n\n      this.fetchMany(unloadedReferences, record);\n    } else {\n      // all requested records are available\n      manyArray.set('isLoaded', true);\n\n      Ember.run.once(function() {\n        manyArray.trigger('didLoad');\n      });\n    }\n\n    return manyArray;\n  },\n\n  /**\n    This method delegates a query to the adapter. This is the one place where\n    adapter-level semantics are exposed to the application.\n\n    Exposing queries this way seems preferable to creating an abstract query\n    language for all server-side queries, and then require all adapters to\n    implement them.\n\n    @private\n    @method findQuery\n    @param {Class} type\n    @param {Object} query an opaque query to be used by the adapter\n    @return {DS.AdapterPopulatedRecordArray}\n  */\n  findQuery: function(type, query) {\n    var array = DS.AdapterPopulatedRecordArray.create({ type: type, query: query, content: Ember.A([]), store: this });\n    var adapter = this.adapterForType(type);\n\n    Ember.assert(\"You tried to load a query but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load a query but your adapter does not implement `findQuery`\", adapter.findQuery);\n\n    adapter.findQuery(this, type, query, array);\n\n    return array;\n  },\n\n  /**\n    @private\n\n    This method returns an array of all records adapter can find.\n    It triggers the adapter's `findAll` method to give it an opportunity to populate\n    the array with records of that type.\n\n    @param {Class} type\n    @return {DS.AdapterPopulatedRecordArray}\n  */\n  findAll: function(type) {\n    return this.fetchAll(type, this.all(type));\n  },\n\n  /**\n    @private\n  */\n  fetchAll: function(type, array) {\n    var adapter = this.adapterForType(type),\n        sinceToken = this.typeMapFor(type).metadata.since;\n\n    set(array, 'isUpdating', true);\n\n    Ember.assert(\"You tried to load all records but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load all records but your adapter does not implement `findAll`\", adapter.findAll);\n\n    adapter.findAll(this, type, sinceToken);\n\n    return array;\n  },\n\n  /**\n  */\n  metaForType: function(type, property, data) {\n    var target = this.typeMapFor(type).metadata;\n    set(target, property, data);\n  },\n\n  /**\n  */\n  didUpdateAll: function(type) {\n    var findAllCache = this.typeMapFor(type).findAllCache;\n    set(findAllCache, 'isUpdating', false);\n  },\n\n  /**\n    This method returns a filtered array that contains all of the known records\n    for a given type.\n\n    Note that because it's just a filter, it will have any locally\n    created records of the type.\n\n    Also note that multiple calls to `all` for a given type will always\n    return the same RecordArray.\n\n    @method all\n    @param {Class} type\n    @return {DS.RecordArray}\n  */\n  all: function(type) {\n    var typeMap = this.typeMapFor(type),\n        findAllCache = typeMap.findAllCache;\n\n    if (findAllCache) { return findAllCache; }\n\n    var array = DS.RecordArray.create({\n      type: type,\n      content: Ember.A([]),\n      store: this,\n      isLoaded: true\n    });\n\n    this.recordArrayManager.registerFilteredRecordArray(array, type);\n\n    typeMap.findAllCache = array;\n    return array;\n  },\n\n  /**\n    Takes a type and filter function, and returns a live RecordArray that\n    remains up to date as new records are loaded into the store or created\n    locally.\n\n    The callback function takes a materialized record, and returns true\n    if the record should be included in the filter and false if it should\n    not.\n\n    The filter function is called once on all records for the type when\n    it is created, and then once on each newly loaded or created record.\n\n    If any of a record's properties change, or if it changes state, the\n    filter function will be invoked again to determine whether it should\n    still be in the array.\n\n    Note that the existence of a filter on a type will trigger immediate\n    materialization of all loaded data for a given type, so you might\n    not want to use filters for a type if you are loading many records\n    into the store, many of which are not active at any given time.\n\n    In this scenario, you might want to consider filtering the raw\n    data before loading it into the store.\n\n    @method filter\n    @param {Class} type\n    @param {Function} filter\n    @return {DS.FilteredRecordArray}\n  */\n  filter: function(type, query, filter) {\n    // allow an optional server query\n    if (arguments.length === 3) {\n      this.findQuery(type, query);\n    } else if (arguments.length === 2) {\n      filter = query;\n    }\n\n    var array = DS.FilteredRecordArray.create({\n      type: type,\n      content: Ember.A([]),\n      store: this,\n      manager: this.recordArrayManager,\n      filterFunction: filter\n    });\n\n    this.recordArrayManager.registerFilteredRecordArray(array, type, filter);\n\n    return array;\n  },\n\n  /**\n    This method returns if a certain record is already loaded\n    in the store. Use this function to know beforehand if a find()\n    will result in a request or that it will be a cache hit.\n\n    @param {Class} type\n    @param {string} id\n    @return {boolean}\n  */\n  recordIsLoaded: function(type, id) {\n    if (!this.hasReferenceForId(type, id)) { return false; }\n    return typeof this.referenceForId(type, id).data === 'object';\n  },\n\n  // ............\n  // . UPDATING .\n  // ............\n\n  /**\n    @private\n\n    If the adapter updates attributes or acknowledges creation\n    or deletion, the record will notify the store to update its\n    membership in any filters.\n\n    To avoid thrashing, this method is invoked only once per\n    run loop per record.\n\n    @param {Class} type\n    @param {Number|String} clientId\n    @param {DS.Model} record\n  */\n  dataWasUpdated: function(type, reference, record) {\n    // Because data updates are invoked at the end of the run loop,\n    // it is possible that a record might be deleted after its data\n    // has been modified and this method was scheduled to be called.\n    //\n    // If that's the case, the record would have already been removed\n    // from all record arrays; calling updateRecordArrays would just\n    // add it back. If the record is deleted, just bail. It shouldn't\n    // give us any more trouble after this.\n\n    if (get(record, 'isDeleted')) { return; }\n\n    if (typeof reference.data === \"object\") {\n      this.recordArrayManager.referenceDidChange(reference);\n    }\n  },\n\n  // ..............\n  // . PERSISTING .\n  // ..............\n\n  /**\n    This method delegates saving to the store's implicit\n    transaction.\n\n    Calling this method is essentially a request to persist\n    any changes to records that were not explicitly added to\n    a transaction.\n  */\n  save: function() {\n    once(this, 'commitDefaultTransaction');\n  },\n  commit: Ember.aliasMethod('save'),\n\n  commitDefaultTransaction: function() {\n    get(this, 'defaultTransaction').commit();\n  },\n\n  scheduleSave: function(record) {\n    get(this, 'currentTransaction').add(record);\n    once(this, 'flushSavedRecords');\n  },\n\n  flushSavedRecords: function() {\n    get(this, 'currentTransaction').commit();\n    set(this, 'currentTransaction', this.transaction());\n  },\n\n  /**\n    Adapters should call this method if they would like to acknowledge\n    that all changes related to a record (other than relationship\n    changes) have persisted.\n\n    Because relationship changes affect multiple records, the adapter\n    is responsible for acknowledging the change to the relationship\n    directly (using `store.didUpdateRelationship`) when all aspects\n    of the relationship change have persisted.\n\n    It can be called for created, deleted or updated records.\n\n    If the adapter supplies new data, that data will become the new\n    canonical data for the record. That will result in blowing away\n    all local changes and rematerializing the record with the new\n    data (the \"sledgehammer\" approach).\n\n    Alternatively, if the adapter does not supply new data, the record\n    will collapse all local changes into its saved data. Subsequent\n    rollbacks of the record will roll back to this point.\n\n    If an adapter is acknowledging receipt of a newly created record\n    that did not generate an id in the client, it *must* either\n    provide data or explicitly invoke `store.didReceiveId` with\n    the server-provided id.\n\n    Note that an adapter may not supply new data when acknowledging\n    a deleted record.\n\n    @see DS.Store#didUpdateRelationship\n\n    @param {DS.Model} record the in-flight record\n    @param {Object} data optional data (see above)\n  */\n  didSaveRecord: function(record, data) {\n    if (data) {\n      this.updateId(record, data);\n      this.updateRecordData(record, data);\n    } else {\n      this.didUpdateAttributes(record);\n    }\n\n    record.adapterDidCommit();\n  },\n\n  /**\n    For convenience, if an adapter is performing a bulk commit, it can also\n    acknowledge all of the records at once.\n\n    If the adapter supplies an array of data, they must be in the same order as\n    the array of records passed in as the first parameter.\n\n    @param {#forEach} list a list of records whose changes the\n      adapter is acknowledging. You can pass any object that\n      has an ES5-like `forEach` method, including the\n      `OrderedSet` objects passed into the adapter at commit\n      time.\n    @param {Array[Object]} dataList an Array of data. This\n      parameter must be an integer-indexed Array-like.\n  */\n  didSaveRecords: function(list, dataList) {\n    var i = 0;\n    list.forEach(function(record) {\n      this.didSaveRecord(record, dataList && dataList[i++]);\n    }, this);\n  },\n\n  /**\n    This method allows the adapter to specify that a record\n    could not be saved because it had backend-supplied validation\n    errors.\n\n    The errors object must have keys that correspond to the\n    attribute names. Once each of the specified attributes have\n    changed, the record will automatically move out of the\n    invalid state and be ready to commit again.\n\n    TODO: We should probably automate the process of converting\n    server names to attribute names using the existing serializer\n    infrastructure.\n\n    @param {DS.Model} record\n    @param {Object} errors\n  */\n  recordWasInvalid: function(record, errors) {\n    record.adapterDidInvalidate(errors);\n  },\n\n  /**\n     This method allows the adapter to specify that a record\n     could not be saved because the server returned an unhandled\n     error.\n\n     @param {DS.Model} record\n  */\n  recordWasError: function(record) {\n    record.adapterDidError();\n  },\n\n  /**\n    This is a lower-level API than `didSaveRecord` that allows an\n    adapter to acknowledge the persistence of a single attribute.\n\n    This is useful if an adapter needs to make multiple asynchronous\n    calls to fully persist a record. The record will keep track of\n    which attributes and relationships are still outstanding and\n    automatically move into the `saved` state once the adapter has\n    acknowledged everything.\n\n    If a value is provided, it clobbers the locally specified value.\n    Otherwise, the local value becomes the record's last known\n    saved value (which is used when rolling back a record).\n\n    Note that the specified attributeName is the normalized name\n    specified in the definition of the `DS.Model`, not a key in\n    the server-provided data.\n\n    Also note that the adapter is responsible for performing any\n    transformations on the value using the serializer API.\n\n    @param {DS.Model} record\n    @param {String} attributeName\n    @param {Object} value\n  */\n  didUpdateAttribute: function(record, attributeName, value) {\n    record.adapterDidUpdateAttribute(attributeName, value);\n  },\n\n  /**\n    This method allows an adapter to acknowledge persistence\n    of all attributes of a record but not relationships or\n    other factors.\n\n    It loops through the record's defined attributes and\n    notifies the record that they are all acknowledged.\n\n    This method does not take optional values, because\n    the adapter is unlikely to have a hash of normalized\n    keys and transformed values, and instead of building\n    one up, it should just call `didUpdateAttribute` as\n    needed.\n\n    This method is intended as a middle-ground between\n    `didSaveRecord`, which acknowledges all changes to\n    a record, and `didUpdateAttribute`, which allows an\n    adapter fine-grained control over updates.\n\n    @param {DS.Model} record\n  */\n  didUpdateAttributes: function(record) {\n    record.eachAttribute(function(attributeName) {\n      this.didUpdateAttribute(record, attributeName);\n    }, this);\n  },\n\n  /**\n    This allows an adapter to acknowledge that it has saved all\n    necessary aspects of a relationship change.\n\n    This is separated from acknowledging the record itself\n    (via `didSaveRecord`) because a relationship change can\n    involve as many as three separate records. Records should\n    only move out of the in-flight state once the server has\n    acknowledged all of their relationships, and this differs\n    based upon the adapter's semantics.\n\n    There are three basic scenarios by which an adapter can\n    save a relationship.\n\n    ### Foreign Key\n\n    An adapter can save all relationship changes by updating\n    a foreign key on the child record. If it does this, it\n    should acknowledge the changes when the child record is\n    saved.\n\n        record.eachRelationship(function(name, meta) {\n          if (meta.kind === 'belongsTo') {\n            store.didUpdateRelationship(record, name);\n          }\n        });\n\n        store.didSaveRecord(record, data);\n\n    ### Embedded in Parent\n\n    An adapter can save one-to-many relationships by embedding\n    IDs (or records) in the parent object. In this case, the\n    relationship is not considered acknowledged until both the\n    old parent and new parent have acknowledged the change.\n\n    In this case, the adapter should keep track of the old\n    parent and new parent, and acknowledge the relationship\n    change once both have acknowledged. If one of the two\n    sides does not exist (e.g. the new parent does not exist\n    because of nulling out the belongs-to relationship),\n    the adapter should acknowledge the relationship once\n    the other side has acknowledged.\n\n    ### Separate Entity\n\n    An adapter can save relationships as separate entities\n    on the server. In this case, they should acknowledge\n    the relationship as saved once the server has\n    acknowledged the entity.\n\n    @see DS.Store#didSaveRecord\n\n    @param {DS.Model} record\n    @param {DS.Model} relationshipName\n  */\n  didUpdateRelationship: function(record, relationshipName) {\n    var clientId = get(record, '_reference').clientId;\n\n    var relationship = this.relationshipChangeFor(clientId, relationshipName);\n    //TODO(Igor)\n    if (relationship) { relationship.adapterDidUpdate(); }\n  },\n\n  /**\n    This allows an adapter to acknowledge all relationship changes\n    for a given record.\n\n    Like `didUpdateAttributes`, this is intended as a middle ground\n    between `didSaveRecord` and fine-grained control via the\n    `didUpdateRelationship` API.\n  */\n  didUpdateRelationships: function(record) {\n    var changes = this.relationshipChangesFor(get(record, '_reference'));\n\n    for (var name in changes) {\n      if (!changes.hasOwnProperty(name)) { continue; }\n      changes[name].adapterDidUpdate();\n    }\n  },\n\n  /**\n    When acknowledging the creation of a locally created record,\n    adapters must supply an id (if they did not implement\n    `generateIdForRecord` to generate an id locally).\n\n    If an adapter does not use `didSaveRecord` and supply a hash\n    (for example, if it needs to make multiple HTTP requests to\n    create and then update the record), it will need to invoke\n    `didReceiveId` with the backend-supplied id.\n\n    When not using `didSaveRecord`, an adapter will need to\n    invoke:\n\n    * didReceiveId (unless the id was generated locally)\n    * didCreateRecord\n    * didUpdateAttribute(s)\n    * didUpdateRelationship(s)\n\n    @param {DS.Model} record\n    @param {Number|String} id\n  */\n  didReceiveId: function(record, id) {\n    var typeMap = this.typeMapFor(record.constructor),\n        clientId = get(record, 'clientId'),\n        oldId = get(record, 'id');\n\n    Ember.assert(\"An adapter cannot assign a new id to a record that already has an id. \" + record + \" had id: \" + oldId + \" and you tried to update it with \" + id + \". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent.\", oldId === undefined || id === oldId);\n\n    typeMap.idToCid[id] = clientId;\n    this.clientIdToId[clientId] = id;\n  },\n\n  /**\n    @private\n\n    This method re-indexes the data by its clientId in the store\n    and then notifies the record that it should rematerialize\n    itself.\n\n    @param {DS.Model} record\n    @param {Object} data\n  */\n  updateRecordData: function(record, data) {\n    get(record, '_reference').data = data;\n    record.didChangeData();\n  },\n\n  /**\n    @private\n\n    If an adapter invokes `didSaveRecord` with data, this method\n    extracts the id from the supplied data (using the adapter's\n    `extractId()` method) and indexes the clientId with that id.\n\n    @param {DS.Model} record\n    @param {Object} data\n  */\n  updateId: function(record, data) {\n    var type = record.constructor,\n        typeMap = this.typeMapFor(type),\n        reference = get(record, '_reference'),\n        oldId = get(record, 'id'),\n        id = this.preprocessData(type, data);\n\n    Ember.assert(\"An adapter cannot assign a new id to a record that already has an id. \" + record + \" had id: \" + oldId + \" and you tried to update it with \" + id + \". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent.\", oldId === null || id === oldId);\n\n    typeMap.idToReference[id] = reference;\n    reference.id = id;\n  },\n\n  /**\n    @private\n\n    This method receives opaque data provided by the adapter and\n    preprocesses it, returning an ID.\n\n    The actual preprocessing takes place in the adapter. If you would\n    like to change the default behavior, you should override the\n    appropriate hooks in `DS.Serializer`.\n\n    @see {DS.Serializer}\n    @return {String} id the id represented by the data\n  */\n  preprocessData: function(type, data) {\n    return this.adapterForType(type).extractId(type, data);\n  },\n\n  /** @private\n   Returns a map of IDs to client IDs for a given type.\n  */\n  typeMapFor: function(type) {\n    var typeMaps = get(this, 'typeMaps'),\n        guid = Ember.guidFor(type),\n        typeMap;\n\n    typeMap = typeMaps[guid];\n\n    if (typeMap) { return typeMap; }\n\n    typeMap = {\n      idToReference: {},\n      references: [],\n      metadata: {}\n    };\n\n    typeMaps[guid] = typeMap;\n\n    return typeMap;\n  },\n\n  // ................\n  // . LOADING DATA .\n  // ................\n\n  /**\n    Load new data into the store for a given id and type combination.\n    If data for that record had been loaded previously, the new information\n    overwrites the old.\n\n    If the record you are loading data for has outstanding changes that have not\n    yet been saved, an exception will be thrown.\n\n    @param {DS.Model} type\n    @param {String|Number} id\n    @param {Object} data the data to load\n  */\n  load: function(type, data, prematerialized) {\n    var id;\n\n    if (typeof data === 'number' || typeof data === 'string') {\n      id = data;\n      data = prematerialized;\n      prematerialized = null;\n    }\n\n    if (prematerialized && prematerialized.id) {\n      id = prematerialized.id;\n    } else if (id === undefined) {\n      id = this.preprocessData(type, data);\n    }\n\n    id = coerceId(id);\n\n    var reference = this.referenceForId(type, id);\n\n    if (reference.record) {\n     once(reference.record, 'loadedData');\n    }\n\n    reference.data = data;\n    reference.prematerialized = prematerialized;\n\n    this.recordArrayManager.referenceDidChange(reference);\n\n    return reference;\n  },\n\n  loadMany: function(type, ids, dataList) {\n    if (dataList === undefined) {\n      dataList = ids;\n      ids = map(dataList, function(data) {\n        return this.preprocessData(type, data);\n      }, this);\n    }\n\n    return map(ids, function(id, i) {\n      return this.load(type, id, dataList[i]);\n    }, this);\n  },\n\n  loadHasMany: function(record, key, ids) {\n    //It looks sad to have to do the conversion in the store\n    var type = record.get(key + '.type'),\n        tuples = map(ids, function(id) {\n          return {id: id, type: type};\n        });\n    record.materializeHasMany(key, tuples);\n\n    // Update any existing many arrays that use the previous IDs,\n    // if necessary.\n    record.hasManyDidChange(key);\n\n    var relationship = record.cacheFor(key);\n\n    // TODO (tomdale) this assumes that loadHasMany *always* means\n    // that the records for the provided IDs are loaded.\n    if (relationship) {\n      set(relationship, 'isLoaded', true);\n      relationship.trigger('didLoad');\n    }\n  },\n\n  /** @private\n\n    Creates a new reference for a given type & ID pair. Metadata about the\n    record can be stored in the reference without having to create a full-blown\n    DS.Model instance.\n\n    @param {DS.Model} type\n    @param {String|Number} id\n    @returns {Reference}\n  */\n  createReference: function(type, id) {\n    var typeMap = this.typeMapFor(type),\n        idToReference = typeMap.idToReference;\n\n    Ember.assert('The id ' + id + ' has already been used with another record of type ' + type.toString() + '.', !id || !idToReference[id]);\n\n    var reference = {\n      id: id,\n      clientId: this.clientIdCounter++,\n      type: type\n    };\n\n    // if we're creating an item, this process will be done\n    // later, once the object has been persisted.\n    if (id) {\n      idToReference[id] = reference;\n    }\n\n    typeMap.references.push(reference);\n\n    return reference;\n  },\n\n  // ..........................\n  // . RECORD MATERIALIZATION .\n  // ..........................\n\n  materializeRecord: function(reference) {\n    var record = reference.type._create({\n      id: reference.id,\n      store: this,\n      _reference: reference\n    });\n\n    reference.record = record;\n\n    get(this, 'defaultTransaction').adoptRecord(record);\n\n    record.loadingData();\n\n    if (typeof reference.data === 'object') {\n      record.loadedData();\n    }\n\n    return record;\n  },\n\n  dematerializeRecord: function(record) {\n    var reference = get(record, '_reference'),\n        type = reference.type,\n        id = reference.id,\n        typeMap = this.typeMapFor(type);\n\n    record.updateRecordArrays();\n\n    if (id) { delete typeMap.idToReference[id]; }\n\n    var loc = typeMap.references.indexOf(reference);\n    typeMap.references.splice(loc, 1);\n  },\n\n  willDestroy: function() {\n    if (get(DS, 'defaultStore') === this) {\n      set(DS, 'defaultStore', null);\n    }\n  },\n\n  // ........................\n  // . RELATIONSHIP CHANGES .\n  // ........................\n\n  addRelationshipChangeFor: function(clientReference, childKey, parentReference, parentKey, change) {\n    var clientId = clientReference.clientId,\n        parentClientId = parentReference ? parentReference.clientId : parentReference;\n    var key = childKey + parentKey;\n    var changes = this.relationshipChanges;\n    if (!(clientId in changes)) {\n      changes[clientId] = {};\n    }\n    if (!(parentClientId in changes[clientId])) {\n      changes[clientId][parentClientId] = {};\n    }\n    if (!(key in changes[clientId][parentClientId])) {\n      changes[clientId][parentClientId][key] = {};\n    }\n    changes[clientId][parentClientId][key][change.changeType] = change;\n  },\n\n  removeRelationshipChangeFor: function(clientReference, childKey, parentReference, parentKey, type) {\n    var clientId = clientReference.clientId,\n        parentClientId = parentReference ? parentReference.clientId : parentReference;\n    var changes = this.relationshipChanges;\n    var key = childKey + parentKey;\n    if (!(clientId in changes) || !(parentClientId in changes[clientId]) || !(key in changes[clientId][parentClientId])){\n      return;\n    }\n    delete changes[clientId][parentClientId][key][type];\n  },\n\n  relationshipChangeFor: function(clientReference, childKey, parentReference, parentKey, type) {\n    var clientId = clientReference.clientId,\n        parentClientId = parentReference ? parentReference.clientId : parentReference;\n    var changes = this.relationshipChanges;\n    var key = childKey + parentKey;\n    if (!(clientId in changes) || !(parentClientId in changes[clientId])){\n      return;\n    }\n    if(type){\n      return changes[clientId][parentClientId][key][type];\n    }\n    else{\n      //TODO(Igor) what if both present\n      return changes[clientId][parentClientId][key][\"add\"] || changes[clientId][parentClientId][key][\"remove\"];\n    }\n  },\n\n  relationshipChangePairsFor: function(reference){\n    var toReturn = [];\n\n    if( !reference ) { return toReturn; }\n\n    //TODO(Igor) What about the other side\n    var changesObject = this.relationshipChanges[reference.clientId];\n    for (var objKey in changesObject){\n      if(changesObject.hasOwnProperty(objKey)){\n        for (var changeKey in changesObject[objKey]){\n          if(changesObject[objKey].hasOwnProperty(changeKey)){\n            toReturn.push(changesObject[objKey][changeKey]);\n          }\n        }\n      }\n    }\n    return toReturn;\n  },\n\n  relationshipChangesFor: function(reference) {\n    var toReturn = [];\n\n    if( !reference ) { return toReturn; }\n\n    var relationshipPairs = this.relationshipChangePairsFor(reference);\n    forEach(relationshipPairs, function(pair){\n      var addedChange = pair[\"add\"];\n      var removedChange = pair[\"remove\"];\n      if(addedChange){\n        toReturn.push(addedChange);\n      }\n      if(removedChange){\n        toReturn.push(removedChange);\n      }\n    });\n    return toReturn;\n  },\n  // ......................\n  // . PER-TYPE ADAPTERS\n  // ......................\n\n  adapterForType: function(type) {\n    this._adaptersMap = this.createInstanceMapFor('adapters');\n\n    var adapter = this._adaptersMap.get(type);\n    if (adapter) { return adapter; }\n\n    return this.get('_adapter');\n  },\n\n  // ..............................\n  // . RECORD CHANGE NOTIFICATION .\n  // ..............................\n\n  recordAttributeDidChange: function(reference, attributeName, newValue, oldValue) {\n    var record = reference.record,\n        dirtySet = new Ember.OrderedSet(),\n        adapter = this.adapterForType(record.constructor);\n\n    if (adapter.dirtyRecordsForAttributeChange) {\n      adapter.dirtyRecordsForAttributeChange(dirtySet, record, attributeName, newValue, oldValue);\n    }\n\n    dirtySet.forEach(function(record) {\n      record.adapterDidDirty();\n    });\n  },\n\n  recordBelongsToDidChange: function(dirtySet, child, relationship) {\n    var adapter = this.adapterForType(child.constructor);\n\n    if (adapter.dirtyRecordsForBelongsToChange) {\n      adapter.dirtyRecordsForBelongsToChange(dirtySet, child, relationship);\n    }\n\n    // adapterDidDirty is called by the RelationshipChange that created\n    // the dirtySet.\n  },\n\n  recordHasManyDidChange: function(dirtySet, parent, relationship) {\n    var adapter = this.adapterForType(parent.constructor);\n\n    if (adapter.dirtyRecordsForHasManyChange) {\n      adapter.dirtyRecordsForHasManyChange(dirtySet, parent, relationship);\n    }\n\n    // adapterDidDirty is called by the RelationshipChange that created\n    // the dirtySet.\n  }\n});\n\nDS.Store.reopenClass({\n  registerAdapter: DS._Mappable.generateMapFunctionFor('adapters', function(type, adapter, map) {\n    map.set(type, adapter);\n  }),\n\n  transformMapKey: function(key) {\n    if (typeof key === 'string') {\n      var transformedKey;\n      transformedKey = get(Ember.lookup, key);\n      Ember.assert(\"Could not find model at path \" + key, transformedKey);\n      return transformedKey;\n    } else {\n      return key;\n    }\n  },\n\n  transformMapValue: function(key, value) {\n    if (Ember.Object.detect(value)) {\n      return value.create();\n    }\n\n    return value;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/store");minispade.register('ember-data/system/transaction', "(function() {var get = Ember.get, set = Ember.set, forEach = Ember.EnumerableUtils.forEach;\n\n/**\n  @module data\n  @submodule data-transaction\n*/\n\n/**\n  A transaction allows you to collect multiple records into a unit of work\n  that can be committed or rolled back as a group.\n\n  For example, if a record has local modifications that have not yet\n  been saved, calling `commit()` on its transaction will cause those\n  modifications to be sent to the adapter to be saved. Calling\n  `rollback()` on its transaction would cause all of the modifications to\n  be discarded and the record to return to the last known state before\n  changes were made.\n\n  If a newly created record's transaction is rolled back, it will\n  immediately transition to the deleted state.\n\n  If you do not explicitly create a transaction, a record is assigned to\n  an implicit transaction called the default transaction. In these cases,\n  you can treat your application's instance of `DS.Store` as a transaction\n  and call the `commit()` and `rollback()` methods on the store itself.\n\n  Once a record has been successfully committed or rolled back, it will\n  be moved back to the implicit transaction. Because it will now be in\n  a clean state, it can be moved to a new transaction if you wish.\n\n  ### Creating a Transaction\n\n  To create a new transaction, call the `transaction()` method of your\n  application's `DS.Store` instance:\n\n      var transaction = App.store.transaction();\n\n  This will return a new instance of `DS.Transaction` with no records\n  yet assigned to it.\n\n  ### Adding Existing Records\n\n  Add records to a transaction using the `add()` method:\n\n      record = App.store.find(App.Person, 1);\n      transaction.add(record);\n\n  Note that only records whose `isDirty` flag is `false` may be added\n  to a transaction. Once modifications to a record have been made\n  (its `isDirty` flag is `true`), it is not longer able to be added to\n  a transaction.\n\n  ### Creating New Records\n\n  Because newly created records are dirty from the time they are created,\n  and because dirty records can not be added to a transaction, you must\n  use the `createRecord()` method to assign new records to a transaction.\n\n  For example, instead of this:\n\n    var transaction = store.transaction();\n    var person = App.Person.createRecord({ name: \"Steve\" });\n\n    // won't work because person is dirty\n    transaction.add(person);\n\n  Call `createRecord()` on the transaction directly:\n\n    var transaction = store.transaction();\n    transaction.createRecord(App.Person, { name: \"Steve\" });\n\n  ### Asynchronous Commits\n\n  Typically, all of the records in a transaction will be committed\n  together. However, new records that have a dependency on other new\n  records need to wait for their parent record to be saved and assigned an\n  ID. In that case, the child record will continue to live in the\n  transaction until its parent is saved, at which time the transaction will\n  attempt to commit again.\n\n  For this reason, you should not re-use transactions once you have committed\n  them. Always make a new transaction and move the desired records to it before\n  calling commit.\n*/\n\nDS.Transaction = Ember.Object.extend({\n  /**\n    @private\n\n    Creates the bucket data structure used to segregate records by\n    type.\n  */\n  init: function() {\n    set(this, 'records', Ember.OrderedSet.create());\n  },\n\n  /**\n    Creates a new record of the given type and assigns it to the transaction\n    on which the method was called.\n\n    This is useful as only clean records can be added to a transaction and\n    new records created using other methods immediately become dirty.\n\n    @param {DS.Model} type the model type to create\n    @param {Object} hash the data hash to assign the new record\n  */\n  createRecord: function(type, hash) {\n    var store = get(this, 'store');\n\n    return store.createRecord(type, hash, this);\n  },\n\n  isEqualOrDefault: function(other) {\n    if (this === other || other === get(this, 'store.defaultTransaction')) {\n      return true;\n    }\n  },\n\n  isDefault: Ember.computed(function() {\n    return this === get(this, 'store.defaultTransaction');\n  }).volatile(),\n\n  /**\n    Adds an existing record to this transaction. Only records without\n    modificiations (i.e., records whose `isDirty` property is `false`)\n    can be added to a transaction.\n\n    @param {DS.Model} record the record to add to the transaction\n  */\n  add: function(record) {\n    Ember.assert(\"You must pass a record into transaction.add()\", record instanceof DS.Model);\n\n    var store = get(this, 'store');\n    var adapter = get(store, '_adapter');\n    var serializer = get(adapter, 'serializer');\n    serializer.eachEmbeddedRecord(record, function(embeddedRecord, embeddedType) {\n      if (embeddedType === 'load') { return; }\n\n      this.add(embeddedRecord);\n    }, this);\n\n    this.adoptRecord(record);\n  },\n\n  relationships: Ember.computed(function() {\n    var relationships = Ember.OrderedSet.create(),\n        records = get(this, 'records'),\n        store = get(this, 'store');\n\n    records.forEach(function(record) {\n      var reference = get(record, '_reference');\n      var changes = store.relationshipChangesFor(reference);\n      for(var i = 0; i < changes.length; i++) {\n        relationships.add(changes[i]);\n      }\n    });\n\n    return relationships;\n  }).volatile(),\n\n  commitDetails: Ember.computed(function() {\n    var commitDetails = Ember.MapWithDefault.create({\n      defaultValue: function() {\n        return {\n          created: Ember.OrderedSet.create(),\n          updated: Ember.OrderedSet.create(),\n          deleted: Ember.OrderedSet.create()\n        };\n      }\n    });\n\n    var records = get(this, 'records'),\n        store = get(this, 'store');\n\n    records.forEach(function(record) {\n      if(!get(record, 'isDirty')) return;\n      record.send('willCommit');\n      var adapter = store.adapterForType(record.constructor);\n      commitDetails.get(adapter)[get(record, 'dirtyType')].add(record);\n    });\n\n    return commitDetails;\n  }).volatile(),\n\n  /**\n    Commits the transaction, which causes all of the modified records that\n    belong to the transaction to be sent to the adapter to be saved.\n\n    Once you call `commit()` on a transaction, you should not re-use it.\n\n    When a record is saved, it will be removed from this transaction and\n    moved back to the store's default transaction.\n  */\n  commit: function() {\n    var store = get(this, 'store');\n\n    if (get(this, 'isDefault')) {\n      set(store, 'defaultTransaction', store.transaction());\n    }\n\n    this.removeCleanRecords();\n\n    var commitDetails = get(this, 'commitDetails'),\n        relationships = get(this, 'relationships');\n\n    commitDetails.forEach(function(adapter, commitDetails) {\n      Ember.assert(\"You tried to commit records but you have no adapter\", adapter);\n      Ember.assert(\"You tried to commit records but your adapter does not implement `commit`\", adapter.commit);\n\n      adapter.commit(store, commitDetails);\n    });\n\n    // Once we've committed the transaction, there is no need to\n    // keep the OneToManyChanges around. Destroy them so they\n    // can be garbage collected.\n    relationships.forEach(function(relationship) {\n      relationship.destroy();\n    });\n  },\n\n  /**\n    Rolling back a transaction resets the records that belong to\n    that transaction.\n\n    Updated records have their properties reset to the last known\n    value from the persistence layer. Deleted records are reverted\n    to a clean, non-deleted state. Newly created records immediately\n    become deleted, and are not sent to the adapter to be persisted.\n\n    After the transaction is rolled back, any records that belong\n    to it will return to the store's default transaction, and the\n    current transaction should not be used again.\n  */\n  rollback: function() {\n    var store = get(this, 'store');\n\n    // Destroy all relationship changes and compute\n    // all references affected\n    var references = Ember.OrderedSet.create();\n    var relationships = get(this, 'relationships');\n    relationships.forEach(function(r) {\n      references.add(r.firstRecordReference);\n      references.add(r.secondRecordReference);\n      r.destroy();\n    });\n\n    var records = get(this, 'records');\n    records.forEach(function(record) {\n      if (!record.get('isDirty')) return;\n      record.send('rollback');\n    });\n\n    // Now that all records in the transaction are guaranteed to be\n    // clean, migrate them all to the store's default transaction.\n    this.removeCleanRecords();\n\n    // Remaining associated references are not part of the transaction, but\n    // can still have hasMany's which have not been reloaded\n    references.forEach(function(r) {\n      if (r && r.record) {\n        var record = r.record;\n        record.suspendRelationshipObservers(function() {\n          record.reloadHasManys();\n        });\n      }\n    }, this);\n  },\n\n  /**\n    @private\n\n    Removes a record from this transaction and back to the store's\n    default transaction.\n\n    Note: This method is private for now, but should probably be exposed\n    in the future once we have stricter error checking (for example, in the\n    case of the record being dirty).\n\n    @param {DS.Model} record\n  */\n  remove: function(record) {\n    var defaultTransaction = get(this, 'store.defaultTransaction');\n    defaultTransaction.adoptRecord(record);\n  },\n\n  /**\n    @private\n\n    Removes all of the records in the transaction's clean bucket.\n  */\n  removeCleanRecords: function() {\n    var records = get(this, 'records');\n    records.forEach(function(record) {\n      if(!record.get('isDirty')) {\n        this.remove(record);\n      }\n    }, this); \n  },\n\n  /**\n    @private\n\n    This method moves a record into a different transaction without the normal\n    checks that ensure that the user is not doing something weird, like moving\n    a dirty record into a new transaction.\n\n    It is designed for internal use, such as when we are moving a clean record\n    into a new transaction when the transaction is committed.\n\n    This method must not be called unless the record is clean.\n\n    @param {DS.Model} record\n  */\n  adoptRecord: function(record) {\n    var oldTransaction = get(record, 'transaction');\n\n    if (oldTransaction) {\n      oldTransaction.removeRecord(record);\n    }\n\n    get(this, 'records').add(record);\n    set(record, 'transaction', this);\n  },\n\n  /**\n   @private\n\n   Removes the record without performing the normal checks\n   to ensure that the record is re-added to the store's\n   default transaction.\n  */\n  removeRecord: function(record) {\n    get(this, 'records').remove(record);\n  }\n\n});\n\nDS.Transaction.reopenClass({\n  ensureSameTransaction: function(records){\n    var transactions = Ember.A();\n    forEach( records, function(record){\n      if (record){ transactions.pushObject(get(record, 'transaction')); }\n    });\n\n    var transaction = transactions.reduce(function(prev, t) {\n      if (!get(t, 'isDefault')) {\n        if (prev === null) { return t; }\n        Ember.assert(\"All records in a changed relationship must be in the same transaction. You tried to change the relationship between records when one is in \" + t + \" and the other is in \" + prev, t === prev);\n      }\n\n      return prev;\n    }, null);\n\n    if (transaction) {\n      forEach( records, function(record){\n        if (record){ transaction.add(record); }\n      });\n    } else {\n      transaction = transactions.objectAt(0);\n    }\n    return transaction;\n   }\n});\n\n})();\n//@ sourceURL=ember-data/system/transaction");minispade.register('ember-data/transforms/json_transforms', "(function() {var isNone = Ember.isNone, isEmpty = Ember.isEmpty;\n\n/**\n  @module data\n  @submodule data-transforms\n*/\n\n/**\n  DS.Transforms is a hash of transforms used by DS.Serializer.\n\n  @class JSONTransforms\n  @static\n  @namespace DS\n*/\nDS.JSONTransforms = {\n  string: {\n    deserialize: function(serialized) {\n      return isNone(serialized) ? null : String(serialized);\n    },\n\n    serialize: function(deserialized) {\n      return isNone(deserialized) ? null : String(deserialized);\n    }\n  },\n\n  number: {\n    deserialize: function(serialized) {\n      return isEmpty(serialized) ? null : Number(serialized);\n    },\n\n    serialize: function(deserialized) {\n      return isEmpty(deserialized) ? null : Number(deserialized);\n    }\n  },\n\n  // Handles the following boolean inputs:\n  // \"TrUe\", \"t\", \"f\", \"FALSE\", 0, (non-zero), or boolean true/false\n  'boolean': {\n    deserialize: function(serialized) {\n      var type = typeof serialized;\n\n      if (type === \"boolean\") {\n        return serialized;\n      } else if (type === \"string\") {\n        return serialized.match(/^true$|^t$|^1$/i) !== null;\n      } else if (type === \"number\") {\n        return serialized === 1;\n      } else {\n        return false;\n      }\n    },\n\n    serialize: function(deserialized) {\n      return Boolean(deserialized);\n    }\n  },\n\n  date: {\n    deserialize: function(serialized) {\n      var type = typeof serialized;\n\n      if (type === \"string\") {\n        return new Date(Ember.Date.parse(serialized));\n      } else if (type === \"number\") {\n        return new Date(serialized);\n      } else if (serialized === null || serialized === undefined) {\n        // if the value is not present in the data,\n        // return undefined, not null.\n        return serialized;\n      } else {\n        return null;\n      }\n    },\n\n    serialize: function(date) {\n      if (date instanceof Date) {\n        var days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n        var months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n        var pad = function(num) {\n          return num < 10 ? \"0\"+num : \"\"+num;\n        };\n\n        var utcYear = date.getUTCFullYear(),\n            utcMonth = date.getUTCMonth(),\n            utcDayOfMonth = date.getUTCDate(),\n            utcDay = date.getUTCDay(),\n            utcHours = date.getUTCHours(),\n            utcMinutes = date.getUTCMinutes(),\n            utcSeconds = date.getUTCSeconds();\n\n\n        var dayOfWeek = days[utcDay];\n        var dayOfMonth = pad(utcDayOfMonth);\n        var month = months[utcMonth];\n\n        return dayOfWeek + \", \" + dayOfMonth + \" \" + month + \" \" + utcYear + \" \" +\n               pad(utcHours) + \":\" + pad(utcMinutes) + \":\" + pad(utcSeconds) + \" GMT\";\n      } else {\n        return null;\n      }\n    }\n  }\n};\n\n})();\n//@ sourceURL=ember-data/transforms/json_transforms");